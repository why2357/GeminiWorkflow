<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini Flow | é«˜æ•ˆä¸€è‡´æ€§å·¥ä½œæµ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
    <style>
        :root {
            /* ç°ä»£è°ƒè‰²æ¿ (Slate & Indigo) */
            --primary: #6366f1;
            /* ä¸»è‰²è°ƒ Indigo-500 */
            --primary-hover: #4f46e5;
            /* Indigo-600 */
            --bg-body: #f8fafc;
            /* Slate-50 */
            --bg-card: #ffffff;
            /* White */
            --text-main: #1e293b;
            /* Slate-800 */
            --text-sub: #64748b;
            /* Slate-500 */
            --border: #e2e8f0;
            /* Slate-200 */
            --input-bg: #f1f5f9;
            /* Slate-100 */
            --success: #10b981;
            /* Emerald */
            --danger: #ef4444;
            /* Red */

            --radius-lg: 16px;
            --radius-md: 12px;
            --radius-sm: 8px;

            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-body);
            color: var(--text-main);
            margin: 0;
            height: 100vh;
            overflow: hidden;
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
            display: flex;
            flex-direction: column;
        }

        /* é¡¶éƒ¨å¯¼èˆª */
        header {
            background: white;
            border-bottom: 1px solid var(--border);
            padding: 0 24px;
            z-index: 100;
            flex-shrink: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 60px;
            box-sizing: border-box;
        }

        h1 {
            margin: 0;
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--text-main);
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .badge {
            background: #e0e7ff;
            color: var(--primary);
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Main 3-Column Layout */
        .app-layout {
            display: grid;
            grid-template-columns: 280px 1fr 280px;
            flex-grow: 1;
            overflow: hidden;
            height: calc(100vh - 60px);
        }

        /* Sidebar Styles */
        .sidebar {
            background: white;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border-right: 1px solid var(--border);
        }

        .sidebar.right {
            border-right: none;
            border-left: 1px solid var(--border);
        }

        .sidebar-header {
            padding: 16px;
            background: #f8fafc;
            border-bottom: 1px solid var(--border);
            font-weight: 600;
            color: var(--text-main);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .sidebar-content {
            flex: 1;
            overflow-y: scroll; /* Force scrollbar to prevent layout shift */
            /* scrollbar-gutter: stable; */ 
            padding: 0;
            background: #f1f5f9;
            display: block; 
        }

        /* Custom Scrollbar for Sidebar to look cleaner */
        .sidebar-content::-webkit-scrollbar {
            width: 6px;
        }
        .sidebar-content::-webkit-scrollbar-track {
            background: transparent;
        }
        .sidebar-content::-webkit-scrollbar-thumb {
            background-color: #cbd5e1;
            border-radius: 3px;
        }
        .sidebar-content::-webkit-scrollbar-thumb:hover {
            background-color: #94a3b8;
        }

        .sidebar-footer {
            padding: 12px;
            background: white;
            border-top: 1px solid var(--border);
            flex-shrink: 0;
        }

        /* Center Column Styles */
        .center-column {
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            padding: 24px;
            gap: 24px;
            background: var(--bg-body);
        }

        /* Cards */
        .card { 
            background: var(--bg-card); 
            border-radius: var(--radius-lg); 
            box-shadow: var(--shadow-sm); 
            border: 1px solid var(--border); 
            overflow: hidden; 
            display: flex; 
            flex-direction: column; 
            flex-shrink: 0; 
        } 
 
        .card.flex-grow { 
            flex-grow: 1; 
            min-height: 400px; 
        } 
 
        .card-header {
            padding: 16px 24px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            background: #fafafa;
        }

        .step-icon {
            width: 28px;
            height: 28px;
            background: var(--primary);
            color: white;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9rem;
            margin-right: 12px;
            box-shadow: 0 2px 4px rgba(99, 102, 241, 0.2);
        }

        .card-title {
            font-size: 1rem;
            font-weight: 600;
        }

        .card-body {
            padding: 24px;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }

        /* Textarea */
        textarea {
            width: 100%;
            height: 100px;
            padding: 12px;
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            background: var(--input-bg);
            font-family: inherit;
            font-size: 0.95rem;
            color: var(--text-main);
            box-sizing: border-box;
            resize: vertical;
            outline: none;
        }

        textarea:focus {
            border-color: var(--primary);
            background: white;
        }

        /* JSON Output */
        .code-block {
            background: #1e293b;
            color: #e2e8f0;
            border-radius: var(--radius-md);
            padding: 16px;
            font-family: 'Menlo', 'Monaco', monospace;
            font-size: 0.85rem;
            margin-top: 16px;
            max-height: 200px;
            overflow-y: auto;
            white-space: pre-wrap;
            display: none;
            border: 1px solid #334155;
        }

        /* Buttons */
        button {
            cursor: pointer;
            border: none;
            font-size: 0.9rem;
            font-weight: 600;
            padding: 8px 16px;
            border-radius: var(--radius-sm);
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        button.primary {
            background-color: var(--primary);
            color: white;
        }

        button.primary:hover {
            background-color: var(--primary-hover);
        }

        button.secondary {
            background-color: white;
            border: 1px solid var(--border);
            color: var(--text-main);
        }

        button.secondary:hover {
            background-color: var(--input-bg);
        }

        button.danger-ghost {
            background: transparent;
            color: var(--text-sub);
            padding: 4px;
        }
        button.danger-ghost:hover {
            color: var(--danger);
            background: #fee2e2;
        }

        /* Upload Zone */
        .upload-zone {
            border: 2px dashed var(--border);
            border-radius: var(--radius-lg);
            padding: 40px;
            text-align: center;
            background: #fdfdfd;
            transition: all 0.2s;
            position: relative;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .upload-zone:hover {
            border-color: var(--primary);
            background: #f0fdfa;
        }

        .upload-zone input {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            opacity: 0;
            cursor: pointer;
        }

        /* Interactive Grid */
        .grid-container {
            display: none; /* Initially hidden */
            flex-direction: column;
            height: 100%;
        }

        .interactive-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 4px;
            background: #e2e8f0;
            padding: 4px;
            border-radius: var(--radius-md);
        }

        .grid-tile {
            position: relative;
            aspect-ratio: 16/9;
            cursor: grab;
            overflow: hidden;
            border-radius: 4px;
            background: white;
            transition: all 0.2s ease;
            user-select: none;
        }

        .grid-tile:active {
            cursor: grabbing;
        }

        .grid-tile img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
            pointer-events: none;
        }

        .grid-tile.is-selected {
            opacity: 1;
            filter: grayscale(0%);
            border: 2px solid var(--primary);
            z-index: 1;
        }

        .grid-tile.is-ignored {
            opacity: 0.4;
            filter: grayscale(100%);
            transform: scale(0.95);
            border: 2px solid transparent;
        }

        .tile-badge {
            position: absolute;
            top: 4px;
            left: 4px;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 4px;
        }

        /* Sidebar Items */
        .selected-item {
            position: relative;
            background: white;
            /* Remove border-radius and margin to make them stack seamlessly */
            border-radius: 0;
            overflow: hidden;
            /* Remove border and shadow */
            border: none;
            border-bottom: 1px solid white; /* Add thin white line separator */
            box-shadow: none;
            display: block; /* Changed to block */
            cursor: grab;
            margin-bottom: 0;
            transition: all 0.2s;
        }

        .selected-item:hover .delete-btn {
            opacity: 1;
        }

        .delete-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 28px;
            height: 28px;
            background: rgba(255, 255, 255, 0.95);
            color: #ef4444;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            opacity: 0;
            transition: all 0.2s;
            z-index: 50;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .delete-btn:hover {
            background: #fff;
            transform: scale(1.1);
            color: #dc2626;
            box-shadow: 0 4px 6px rgba(0,0,0,0.15);
        }

        .selected-item-frame {
            /* Ensure frame takes full width */
            width: 100%;
            background: #000;
            /* Force reset any potential height constraints */
            height: auto;
            min-height: 0;
            display: block;
            line-height: 0; /* Remove potential text line-height gaps */
        }

        .selected-item-frame img {
            width: 100%;
            height: auto;
            display: block;
            vertical-align: top; /* Changed from bottom to top to be safe */
            border: none;
            margin: 0;
            padding: 0;
        }

        .selected-item-info {
            display: none; /* Hide the info bar as per screenshot */
        }

        .selected-item:last-child {
            border-bottom: none;
        }

        .session-item {
            background: white;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
        }

        .session-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .session-item.active {
            border-color: var(--primary);
            ring: 2px solid rgba(99, 102, 241, 0.2);
        }

        .session-thumb {
            width: 100%;
            aspect-ratio: 16/9;
            object-fit: cover;
            background: #e2e8f0;
            border-bottom: 1px solid #f1f5f9;
        }

        .session-info {
            padding: 8px 12px;
            font-size: 0.85rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .session-meta {
            color: var(--text-sub);
            font-size: 0.75rem;
        }

        .sortable-ghost { 
            opacity: 1 !important;
            background: #f1f5f9 !important;
            border: 2px dashed var(--primary) !important;
            box-shadow: none !important;
            transform: none !important;
            filter: none !important;
        }
        
        .sortable-ghost img, 
        .sortable-ghost .tile-badge {
            opacity: 0.5 !important;
            visibility: visible !important;
            filter: grayscale(100%) !important;
        }

        .sortable-drag { 
            cursor: grabbing; 
            opacity: 1 !important; 
            /* transform: scale(1.05);  Removed to avoid conflict with SortableJS positioning */
            z-index: 9999; 
            box-shadow: 0 25px 50px -12px rgb(0 0 0 / 0.25);
            border-radius: var(--radius-md);
            border: 1px solid var(--primary);
            pointer-events: none !important; /* Critical for drag detection */
            transition: none !important; /* Critical: prevent lag during drag */
        }
        
        /* Drop Zone Highlight */
        .highlight-drop-zone {
            background-color: #f0fdfa !important; /* Light teal/blue background */
            box-shadow: inset 0 0 0 2px var(--primary);
            transition: all 0.3s ease;
        }

        /* ================= CHAT UI STYLES ================= */
        .chat-stream {
            display: flex;
            flex-direction: column;
            gap: 32px;
            padding-bottom: 60px;
        }

        .chat-message {
            display: flex;
            gap: 16px;
            opacity: 0;
            animation: fadeIn 0.5s forwards;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .chat-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            flex-shrink: 0;
            box-shadow: 0 4px 6px -1px rgba(99, 102, 241, 0.3);
        }

        .chat-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-width: 100%;
        }

        .chat-name {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-sub);
            margin-left: 4px;
        }

        /* Override Card for Chat Bubble look */
        .chat-bubble {
            background: white;
            border-radius: 0 16px 16px 16px;
            box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border: 1px solid var(--border);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .chat-bubble.user-bubble {
             border-radius: 16px 0 16px 16px;
             background: #eff6ff;
             border-color: #bfdbfe;
        }

        /* Script Item Styles */
        .script-item {
            background: white;
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            padding: 16px;
            display: flex;
            gap: 16px;
            transition: all 0.2s;
        }
        
        .script-item:hover {
            border-color: var(--primary);
            box-shadow: var(--shadow-sm);
        }

        .shot-badge {
            background: #e0e7ff;
            color: var(--primary);
            font-weight: 700;
            font-size: 0.85rem;
            padding: 4px 8px;
            border-radius: 6px;
            height: fit-content;
            flex-shrink: 0;
            white-space: nowrap;
        }

        .script-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .script-textarea {
            width: 100%;
            min-height: 60px;
            padding: 8px;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 0.9rem;
            resize: none;
            overflow-y: hidden;
            font-family: inherit;
            background: #f8fafc;
        }

        .script-textarea:focus {
            background: white;
            border-color: var(--primary);
            outline: none;
        }

        /* Hide steps initially */
        .step-hidden {
            display: none !important;
        }

/* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: white;
            border-radius: var(--radius-lg);
            width: 600px;
            max-width: 90%;
            box-shadow: var(--shadow-lg);
            display: flex;
            flex-direction: column;
            transform: translateY(20px);
            transition: transform 0.2s;
        }

        .modal-overlay.active .modal {
            transform: translateY(0);
        }

        .modal-header {
            padding: 16px 24px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            font-size: 1.1rem;
        }

        .modal-body {
            padding: 24px;
        }

        .modal-footer {
            padding: 16px 24px;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            background: #f8fafc;
            border-radius: 0 0 var(--radius-lg) var(--radius-lg);
        }

        /* Improved Ref Upload Styles */
        .ref-drop-zone {
            margin-top: 16px;
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            padding: 20px;
            background: #fafafa;
            transition: all 0.2s;
            min-height: 120px;
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: center;
            cursor: pointer;
            position: relative;
        }

        .ref-drop-zone:hover, .ref-drop-zone.drag-over {
            border-color: var(--primary);
            background: #f0f9ff;
        }

        .ref-placeholder {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: var(--text-sub);
            pointer-events: none;
            transition: all 0.2s;
        }

        .ref-placeholder.has-items {
            display: none;
        }

        /* Icon removed as requested */

        .ref-image-item {
            width: 80px;
            height: 80px;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            border: 1px solid var(--border);
            box-shadow: var(--shadow-sm);
            flex-shrink: 0;
            animation: fadeIn 0.3s ease;
            background: white;
        }

        .ref-image-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .ref-image-delete {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 20px;
            height: 20px;
            background: rgba(0,0,0,0.6);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.2s;
            cursor: pointer;
            z-index: 2;
        }

        .ref-image-item:hover .ref-image-delete {
            opacity: 1;
        }
        
        .ref-add-more {
            width: 80px;
            height: 80px;
            border-radius: 8px;
            border: 1px dashed var(--primary);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--primary);
            background: rgba(99, 102, 241, 0.05);
            font-size: 24px;
            flex-shrink: 0;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }
    </style>
</head>

<body>

    <header>
        <h1>
            <span style="font-size: 24px;">ğŸ’</span>
            Gemini Workflow
            <span class="badge">v2.1 Layout</span>
        </h1>
        <!-- Removed Print Button -->
    </header>

    <div class="app-layout">
        
        <!-- LEFT COLUMN: Selected Slices -->
        <aside class="sidebar">
            <div class="sidebar-header">
                <span>ğŸ¬ å·²é€‰åˆ†é•œ</span>
                <span class="badge" id="leftCountBadge">0</span>
            </div>
            <div class="sidebar-content" id="selectedList">
                <div style="text-align: center; color: #94a3b8; padding: 20px; font-size: 0.85rem;">
                    ä»ä¸­é—´ç‚¹å‡»å›¾ç‰‡<br>æ·»åŠ åˆ°æ­¤å¤„<br><br>å¯æ‹–æ‹½æ’åº
                </div>
            </div>
            <div class="sidebar-footer" style="display: flex; gap: 8px;">
                <button class="secondary" style="flex: 1; padding: 0;" onclick="openCollageModal()">ğŸ§© å®«æ ¼æ‹¼åˆ</button>
                <button class="primary" style="flex: 1; padding: 0;" onclick="exportSelectedList()">ğŸ“¦ å¯¼å‡ºå·²é€‰</button>
            </div>
        </aside>

        <!-- CENTER COLUMN: Main Work Area -->
        <main class="center-column">
            
            <div class="chat-stream">

                <!-- Step 1: Script Splitting -->
                <div class="chat-message" id="step-split">
                    <div class="chat-avatar">ğŸ¤–</div>
                    <div class="chat-content">
                        <div class="chat-name">AI Agent</div>
                        <div class="chat-bubble" id="card-split">
                            <div class="card-header" style="justify-content: space-between;">
                                <span class="card-title">å‰§æœ¬æ‹†åˆ† (AI Analysis)</span>
                                <button class="secondary" style="padding: 4px 8px; font-size: 0.8rem;" onclick="openPromptModal('split')">âš™ï¸ é¢„è®¾æç¤ºè¯</button>
                            </div>
                            <div class="card-body" style="flex-grow: 0;">
                                <p style="margin-top:0; margin-bottom:12px; font-size:0.9rem; color:var(--text-sub);">
                                    ä½ å¥½ï¼æˆ‘æ˜¯ä½ çš„åˆ†é•œåŠ©æ‰‹ã€‚è¯·å…ˆç²˜è´´ä½ çš„é•¿ç¯‡å‰§æœ¬ï¼Œæˆ‘ä¼šå¸®ä½ æ‹†åˆ†æˆå…³é”®åœºæ™¯ã€‚
                                </p>
                                <textarea id="fullScriptInput" placeholder="åœ¨æ­¤ç²˜è´´é•¿ç¯‡å‰§æœ¬ï¼ˆçº¦5000å­—ï¼‰..." style="min-height: 150px; overflow-y: hidden; resize: none;" oninput="this.style.height='auto';this.style.height=this.scrollHeight+'px'"></textarea>
                                <div style="margin-top: 12px; display: flex; justify-content: flex-end;">
                                    <button class="primary" onclick="splitScript()">ğŸ¤– AI æ™ºèƒ½æ‹†åˆ†</button>
                                </div>
                                
                                <!-- Split Results Area -->
                                <div id="splitResults" style="margin-top: 16px; display: none; gap: 12px; flex-direction: column;">
                                    <!-- Results will be injected here -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Step 2: Script Generation (Initially Hidden) -->
                <div class="chat-message step-hidden" id="step-input">
                    <div class="chat-avatar">ğŸ¤–</div>
                    <div class="chat-content">
                        <div class="chat-name">AI Agent</div>
                        <div class="chat-bubble" id="card-input">
                            <div class="card-header" style="justify-content: space-between;">
                                <span class="card-title">ç‰‡æ®µé€‰å– (Segment Selection)</span>
                                <button class="secondary" style="padding: 4px 8px; font-size: 0.8rem;" onclick="openPromptModal('shot')">âš™ï¸ é¢„è®¾æç¤ºè¯</button>
                            </div>
                            <div class="card-body" style="flex-grow: 0;">
                                <p style="margin-top:0; margin-bottom:12px; font-size:0.9rem; color:var(--text-sub);">
                                    å·²æå–è¯¥ç‰‡æ®µã€‚ä½ å¯ä»¥ä¿®æ”¹ç‰‡æ®µæè¿°ï¼Œç„¶åç‚¹å‡»ç”Ÿæˆè„šæœ¬ã€‚
                                </p>
                                <textarea id="scriptInput" placeholder="è¾“å…¥æ‚¨çš„ç‰‡æ®µæè¿°... æˆ–ä»ä¸Šæ–¹æ‹†åˆ†ç»“æœä¸­é€‰æ‹©" style="overflow-y: hidden; min-height: 100px; resize: none;" oninput="this.style.height = 'auto'; this.style.height = this.scrollHeight + 'px'"></textarea>
                                
                                <!-- Reference Images Upload -->
                                <div id="sceneRefDropZone" class="ref-drop-zone">
                                    <div class="ref-placeholder" id="sceneRefPlaceholder">
                                        <span style="font-size: 0.85rem;">è¯·ä¸Šä¼ åœºæ™¯å‚è€ƒå›¾ (ç‚¹å‡»æˆ–æ‹–æ‹½ä¸Šä¼ )</span>
                                    </div>
                                    <div id="sceneRefImages" style="display: contents;"></div>
                                    <input type="file" multiple accept="image/*" id="sceneRefUpload" style="display: none;" onchange="handleRefUpload(this, 'sceneRefImages')">
                                </div>

                                <div style="margin-top: 12px; display: flex; justify-content: flex-end; gap: 10px;">
                                    <button class="primary" onclick="generatePrompts()">âœ¨ ç”Ÿæˆåˆ†é•œè„šæœ¬</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Step 3: Script Review -->
                <div class="chat-message step-hidden" id="step-script-review">
                    <div class="chat-avatar">ğŸ¤–</div>
                    <div class="chat-content">
                        <div class="chat-name">AI Agent</div>
                        <div class="chat-bubble" id="card-script-review">
                            <div class="card-header">
                                <span class="card-title">è„šæœ¬ç¡®è®¤ (Script Confirmation)</span>
                            </div>
                            <div class="card-body" style="flex-grow: 0;">
                                <p style="margin-top:0; margin-bottom:12px; font-size:0.9rem; color:var(--text-sub);">
                                    åˆ†é•œè„šæœ¬å·²ç”Ÿæˆã€‚è¯·æ£€æŸ¥å¹¶è¿›è¡ŒäºŒæ¬¡ä¿®æ”¹ï¼Œç¡®è®¤æ— è¯¯åç”Ÿæˆç”»é¢ã€‚
                                </p>
                                
                                <!-- Script List Container -->
                                <div id="scriptListContainer" style="display: flex; flex-direction: column; gap: 12px; max-height: 600px; overflow-y: auto; padding-right: 4px;">
                                    <!-- Items will be injected here -->
                                    <div style="text-align: center; color: var(--text-sub); padding: 20px;">ç­‰å¾…ç”Ÿæˆ...</div>
                                </div>
                                
                                <!-- Reference Images Upload (Script Step) -->
                                <div id="scriptRefDropZone" class="ref-drop-zone">
                                    <div class="ref-placeholder" id="scriptRefPlaceholder">
                                        <span style="font-size: 0.85rem;">ä¸Šä¼ è§’è‰²å’Œåœºæ™¯å‚è€ƒå›¾ (ç‚¹å‡»æˆ–æ‹–æ‹½ä¸Šä¼ )</span>
                                    </div>
                                    <div id="scriptRefImages" style="display: contents;"></div>
                                    <input type="file" multiple accept="image/*" id="scriptRefUpload" style="display: none;" onchange="handleRefUpload(this, 'scriptRefImages')">
                                </div>

                                <div style="margin-top: 12px; display: flex; justify-content: flex-end; gap: 10px;">
                                    <button class="primary" onclick="generateAndLoadImages()">ğŸ¨ ç”Ÿæˆåˆ†é•œç”»é¢</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Step 4: Interactive Workspace (Old Step 3) -->
                <div class="chat-message step-hidden" id="step-workspace">
                    <div class="chat-avatar">ğŸ¤–</div>
                    <div class="chat-content">
                        <div class="chat-name">AI Agent</div>
                        <div class="chat-bubble flex-grow" id="card-workspace" style="min-height: 500px;">
                            <div class="card-header" style="justify-content: space-between;">
                                <div style="display:flex; align-items:center;">
                                    <span class="card-title">äº¤äº’å¼å·¥ä½œå°</span>
                                </div>
                                <div id="workspaceActions" style="display:none; gap: 8px;">
                                    <button class="primary" onclick="confirmSelection()">âœ… ç¡®è®¤é€‰æ‹©</button>
                                    <button class="secondary" onclick="document.getElementById('imageUpload').click()" style="padding: 6px 12px; font-size: 0.8rem;">â• æœ¬åœ°å¯¼å…¥</button>
                                </div>
                            </div>
                            <div class="card-body" style="padding: 0; position: relative;">
                                
                                <!-- View 1: Upload -->
                                <div class="upload-zone" id="uploadArea">
                                    <input type="file" id="imageUpload" accept="image/*" onchange="handleImageUpload(this)">
                                    <div style="font-size: 2rem; margin-bottom: 10px;">ğŸ“‚</div>
                                    <div style="font-weight: 600; margin-bottom: 4px;">ç‚¹å‡»ä¸Šä¼ å›¾ç‰‡</div>
                                    <div style="color: var(--text-sub); font-size: 0.85rem;">æˆ–æ‹–æ‹½æ–‡ä»¶åˆ°æ­¤å¤„</div>
                                </div>

                                <!-- View 2: Grid -->
                                <div class="grid-container" id="gridContainer">
                                    <div id="interactiveGrid" class="interactive-grid"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Step 5: Results (Old Step 4) -->
                <div class="chat-message step-hidden" id="step-results">
                    <div class="chat-avatar">ğŸ¤–</div>
                    <div class="chat-content">
                        <div class="chat-name">AI Agent</div>
                        <div class="chat-bubble" id="card-results">
                            <div class="card-header">
                                <span class="card-title">ç»“æœä¸è¯´æ˜</span>
                            </div>
                            <div class="card-body" style="flex-grow: 0;">
                                <div id="summaryText" style="font-size:0.9rem; color: var(--text-sub);">
                                    åœ¨è¿™é‡Œå¯ä»¥çœ‹åˆ°ä½ åœ¨å·¥ä½œå°ä¸­çš„é€‰æ‹©ç»“æœä¸ç®€å•è¯´æ˜ã€‚
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

            </div>
        </main>

        <!-- RIGHT COLUMN: History -->
        <aside class="sidebar right">
            <div class="sidebar-header">
                <span>ğŸ•˜ å†å²è®°å½•</span>
            </div>
            <div class="sidebar-content" id="sessionList">
                <div style="text-align: center; color: #94a3b8; padding: 20px; font-size: 0.85rem;">
                    æš‚æ— åˆ‡ç‰‡
                </div>
            </div>
        </aside>

    </div>

<!-- Modal for Prompt Config -->
    <div class="modal-overlay" id="promptModal">
        <div class="modal">
            <div class="modal-header">
                <span>âš™ï¸ é…ç½®é¢„è®¾æç¤ºè¯</span>
                <button class="danger-ghost" onclick="closeModal()">Ã—</button>
            </div>
            <div class="modal-body">
                <p style="margin-top: 0; color: var(--text-sub); font-size: 0.9rem; margin-bottom: 12px;">
                    ä¿®æ”¹å‘é€ç»™ AI çš„ç³»ç»Ÿæç¤ºè¯ï¼ˆSystem Promptï¼‰ã€‚è¿™å°†å½±å“ç”Ÿæˆç»“æœçš„é£æ ¼å’Œæ ¼å¼ã€‚
                </p>
                <textarea id="promptConfigInput" style="height: 200px; font-family: monospace; font-size: 0.85rem;" placeholder="è¾“å…¥ç³»ç»Ÿæç¤ºè¯..."></textarea>
            </div>
            <div class="modal-footer">
                <button class="secondary" onclick="closeModal()">å–æ¶ˆ</button>
                <button class="primary" onclick="savePrompt()">ğŸ’¾ ä¿å­˜ä¿®æ”¹</button>
            </div>
        </div>
    </div>

    <!-- Modal for Collage -->
    <div class="modal-overlay" id="collageModal">
        <div class="modal" style="max-width: 1400px; width: 95%; height: 90vh; display: flex; flex-direction: column;">
            <div class="modal-header">
                <span>ğŸ§© å®«æ ¼æ‹¼åˆå¯¼å‡º</span>
                <button class="danger-ghost" onclick="closeCollageModal()">Ã—</button>
            </div>
            <div class="modal-body" style="display: flex; gap: 20px; flex: 1; overflow: hidden; padding: 20px;">
                <!-- Left: Source Images -->
                <div style="width: 220px; display: flex; flex-direction: column; gap: 10px; border-right: 1px solid var(--border); padding-right: 20px;">
                    <div style="font-weight: 600; font-size: 0.9rem; display: flex; justify-content: space-between; align-items: center;">
                        å¯é€‰ç´ æ
                        <span style="font-size: 0.75rem; color: var(--text-sub); font-weight: normal;">æ‹–æ‹½è‡³å³ä¾§</span>
                    </div>
                    <div id="collageSourceList" style="flex: 1; overflow-y: auto; display: block; padding: 0;">
                        <!-- Items injected by JS -->
                    </div>
                </div>
                
                <!-- Right: Canvas Area -->
                <div style="flex: 1; display: flex; flex-direction: column; gap: 16px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; background: #f8fafc; padding: 10px; border-radius: 8px;">
                        <div style="display: flex; gap: 12px; align-items: center;">
                            <span style="font-size: 0.9rem; font-weight: 600;">å¸ƒå±€è®¾ç½®:</span>
                            <select id="collageGridSelect" onchange="updateCollageGrid()" style="padding: 6px 12px; border-radius: 6px; border: 1px solid var(--border); outline: none;">
                                <option value="2x2">2 x 2 (å››å®«æ ¼)</option>
                                <option value="2x3">2 x 3 (å…­å®«æ ¼)</option>
                                <option value="3x3" selected>3 x 3 (ä¹å®«æ ¼)</option>
                                <option value="4x4">4 x 4 (åå…­å®«æ ¼)</option>
                                <option value="5x5">5 x 5 (äºŒåäº”å®«æ ¼)</option>
                            </select>
                        </div>
                        <button class="primary" onclick="exportCollageImage()">ğŸ–¼ï¸ å¯¼å‡ºå®Œæ•´å›¾ç‰‡</button>
                    </div>
                    
                    <div style="flex: 1; background: #e2e8f0; border-radius: 8px; padding: 20px; overflow: auto; display: flex; justify-content: center; align-items: center; position: relative;">
                        <div id="collageContainer" class="collage-container">
                            <!-- Grid Cells -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <style>
        .collage-container {
            display: grid;
            gap: 0;
            background: white;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
            width: 100%;
            height: 100%; /* Fill height to maximize size */
            max-width: none; /* Remove width restriction */
            aspect-ratio: auto; /* Allow flexible aspect ratio based on grid content */
        }
        
        .collage-cell {
            aspect-ratio: 16/9;
            background: #f8fafc;
            border: 1px dashed #cbd5e1;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
            transition: all 0.2s;
        }
        
        .collage-cell:hover {
            border-color: var(--primary);
            background: #f1f5f9;
        }
        
        .source-item {
            position: relative;
            background: white;
            border-radius: 0;
            overflow: hidden;
            border: none;
            border-bottom: 1px solid white;
            box-shadow: none;
            display: block;
            cursor: grab;
            margin-bottom: 0;
            transition: all 0.2s;
        }
        
        .source-item:hover {
            opacity: 0.9;
        }
        
        .source-item img {
            width: 100%;
            display: block;
            border-radius: 0;
        }
        
        /* Scrollbar styling for modal lists */
        #collageSourceList::-webkit-scrollbar {
            width: 6px;
        }
        #collageSourceList::-webkit-scrollbar-track {
            background: transparent;
        }
        #collageSourceList::-webkit-scrollbar-thumb {
            background-color: #cbd5e1;
            border-radius: 3px;
        }
    </style>

    <script>
        function initRefDragAndDrop(dropZoneId, fileInputId) {
            const dropZone = document.getElementById(dropZoneId);
            const fileInput = document.getElementById(fileInputId);
            
            if (!dropZone || !fileInput) return;

            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, preventDefaults, false);
            });

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            ['dragenter', 'dragover'].forEach(eventName => {
                dropZone.addEventListener(eventName, highlight, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, unhighlight, false);
            });

            function highlight(e) {
                dropZone.style.backgroundColor = '#f1f5f9';
                dropZone.style.borderColor = '#94a3b8';
            }

            function unhighlight(e) {
                dropZone.style.backgroundColor = '#fafafa';
                dropZone.style.borderColor = 'var(--border)';
            }

            dropZone.addEventListener('drop', handleDrop, false);

            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                
                // Manually trigger the handler since we can't easily set files to input (security restriction in some browsers, 
                // but we can pass the file list directly to our handler)
                // However, we can create a mock object that looks like an input element
                if (files && files.length > 0) {
                     handleRefUpload({ files: files, value: '' }, dropZone.querySelector('div[id$="RefImages"]').id);
                }
            }
            
            // Allow clicking anywhere in the box to trigger upload (except on existing images)
            dropZone.addEventListener('click', function(e) {
                if(e.target === dropZone || e.target.closest('.upload-trigger')) {
                    fileInput.click();
                }
            });
        }

        // Initialize drag and drop when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
             initRefDragAndDrop('sceneRefDropZone', 'sceneRefUpload');
             initRefDragAndDrop('scriptRefDropZone', 'scriptRefUpload');
        });

        // ================= PROMPT CONFIG SYSTEM =================
        const promptConfig = {
            split: "ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„ç”µå½±åˆ†é•œå¸ˆã€‚è¯·åˆ†æä»¥ä¸‹å‰§æœ¬ï¼Œå°†å…¶æ‹†åˆ†ä¸ºå…³é”®çš„åœºæ™¯ç‰‡æ®µã€‚å¯¹äºæ¯ä¸ªç‰‡æ®µï¼Œè¯·æä¾›ä¸€ä¸ªç®€çŸ­çš„æ ‡é¢˜å’Œä¸€æ®µè¯¦ç»†çš„è§†è§‰æè¿°ã€‚",
            shot: "åŸºäºä»¥ä¸‹åœºæ™¯æè¿°ï¼Œç”Ÿæˆ25ä¸ªè¿ç»­çš„åˆ†é•œç”»é¢æè¿°ã€‚æ¯ä¸ªç”»é¢åº”åŒ…å«è¿é•œæ–¹å¼ã€æ™¯åˆ«ã€å…‰å½±ç»†èŠ‚å’Œå…·ä½“çš„åŠ¨ä½œæè¿°ã€‚é£æ ¼ä¸ºèµ›åšæœ‹å…‹ç”µå½±æ„Ÿï¼Œ8Kåˆ†è¾¨ç‡ã€‚"
        };
        
        let currentEditingPromptType = null;

        function openPromptModal(type) {
            currentEditingPromptType = type;
            const modal = document.getElementById('promptModal');
            const textarea = document.getElementById('promptConfigInput');
            
            textarea.value = promptConfig[type];
            modal.classList.add('active');
        }

        function closeModal() {
            document.getElementById('promptModal').classList.remove('active');
            currentEditingPromptType = null;
        }

        function savePrompt() {
            if (!currentEditingPromptType) return;
            
            const textarea = document.getElementById('promptConfigInput');
            promptConfig[currentEditingPromptType] = textarea.value;
            
            console.log(`Updated ${currentEditingPromptType} prompt:`, promptConfig[currentEditingPromptType]);
            closeModal();
        }

        /* ================= é€»è¾‘ä»£ç  ================= */

        // 0. Step 1: Script Splitting Logic
        function splitScript() {
            const input = document.getElementById('fullScriptInput').value;
            const btn = document.querySelector('#card-split button.primary');
            const resultArea = document.getElementById('splitResults');
            
            if (!input || input.length < 5) {
                // Allow short input for demo purposes, but warn if empty
                if(!input) {
                    alert("è¯·å…ˆè¾“å…¥å‰§æœ¬å†…å®¹");
                    return;
                }
            }

            const originalText = btn.innerHTML;
            btn.disabled = true;
            btn.innerHTML = 'ğŸ¤– åˆ†æä¸­...';
            
            // Mock AI processing delay
            setTimeout(() => {
                btn.disabled = false;
                btn.innerHTML = originalText;
                resultArea.style.display = 'flex';
                
                // Mock scenes based on input or default
                const baseText = input.length > 20 ? input.substring(0, 20) + "..." : "èµ›åšæœ‹å…‹...";
                const scenes = [
                    { title: "ç‰‡æ®µä¸€ï¼šå¼€ç«¯", content: input || "èµ›åšæœ‹å…‹é›¨å¤œï¼Œä¾¦æ¢åœ¨éœ“è™¹ç¯ä¸‹è¡Œèµ°ï¼Œçªç„¶å›å¤´ï¼Œå‘ç°é»‘å½±ã€‚ä»–æ‹”å‡ºæ­¦å™¨ï¼Œé›¨æ°´é¡ºç€å¸½æªæ»´è½ã€‚" },
                    { title: "ç‰‡æ®µäºŒï¼šå‘å±•", content: "æ˜æš—çš„åœ°ä¸‹é…’å§ï¼Œå…¨æ¯èˆå¥³åœ¨ç©ºä¸­æ‰­åŠ¨ã€‚ä¾¦æ¢æ¨å¼€é—¨ï¼Œæ‰€æœ‰äººçš„ç›®å…‰éƒ½èšé›†åœ¨ä»–èº«ä¸Šã€‚" },
                    { title: "ç‰‡æ®µä¸‰ï¼šé«˜æ½®", content: "é£è¡Œè½¦åœ¨æ‘©å¤©å¤§æ¥¼é—´ç©¿æ¢­ï¼Œå¼•æ“è½°é¸£ã€‚ä¾¦æ¢é©¾é©¶ç€è€æ—§çš„é£è½¦ï¼Œæ­»æ­»å’¬ä½å‰æ–¹çš„è±ªåç©¿æ¢­æœºã€‚" }
                ];
                
                resultArea.innerHTML = '';
                scenes.forEach((scene, index) => {
                    const div = document.createElement('div');
                    div.style.cssText = "padding: 12px; background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; cursor: pointer; transition: all 0.2s;";
                    div.onmouseover = () => { div.style.background = '#f1f5f9'; div.style.borderColor = '#cbd5e1'; };
                    div.onmouseout = () => { div.style.background = '#f8fafc'; div.style.borderColor = '#e2e8f0'; };
                    div.onclick = () => selectScene(scene.content);
                    
                    div.innerHTML = `
                        <div style="font-weight: 600; color: #475569; margin-bottom: 4px;">${scene.title}</div>
                        <div style="font-size: 0.85rem; color: #64748b; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden;">${scene.content}</div>
                    `;
                    resultArea.appendChild(div);
                });
            }, 800);
        }

        function selectScene(content) {
            const scriptInput = document.getElementById('scriptInput');
            scriptInput.value = content;
            
            // Show Step 2 (Scene Description)
            const stepInput = document.getElementById('step-input');
            stepInput.classList.remove('step-hidden');
            stepInput.scrollIntoView({ behavior: 'smooth', block: 'start' });
            
            // Highlight effect
            scriptInput.style.transition = 'background 0.3s';
            scriptInput.style.background = '#e0e7ff';
            setTimeout(() => scriptInput.style.background = '#f1f5f9', 500);
        }

        // 1. Generate Script / Prompts
        function generatePrompts() {
            const input = document.getElementById('scriptInput').value || "é»˜è®¤å‰§æœ¬";
            const btn = document.querySelector('#card-input button.primary');
            const originalText = btn.innerText;
            
            btn.innerText = "âœ¨ ç”Ÿæˆä¸­...";
            btn.disabled = true;

            setTimeout(() => {
                btn.innerText = originalText;
                btn.disabled = false;

                // Show Step 3 (Script Review)
                const stepReview = document.getElementById('step-script-review');
                stepReview.classList.remove('step-hidden');
                stepReview.scrollIntoView({ behavior: 'smooth', block: 'start' });
                
                // Transfer Reference Images
                const sceneRefContainer = document.getElementById('sceneRefImages');
                const scriptRefContainer = document.getElementById('scriptRefImages');
                scriptRefContainer.innerHTML = ''; // Clear previous
                
                if (sceneRefContainer.children.length > 0) {
                    Array.from(sceneRefContainer.children).forEach(child => {
                        const clone = child.cloneNode(true);
                        // Re-bind click event isn't strictly needed for inline onclick attribute, 
                        // but let's ensure it works by relying on the attribute logic
                        scriptRefContainer.appendChild(clone);
                    });
                }

                // Generate Mock Prompts (25 shots)
                const container = document.getElementById('scriptListContainer');
                container.innerHTML = '';
                
                for(let i = 0; i < 25; i++) {
                    const shotNum = i + 1;
                    const content = `Cinematic shot, ${input.substring(0, 10)}..., 8k resolution, detailed texture, volumetric lighting.`;
                    
                    const item = document.createElement('div');
                    item.className = 'script-item';
                    item.innerHTML = `
                        <div class="shot-badge">Shot ${shotNum}</div>
                        <div class="script-content">
                            <textarea class="script-textarea" oninput="this.style.height='auto';this.style.height=this.scrollHeight+'px'">${content}</textarea>
                        </div>
                    `;
                    container.appendChild(item);
                    
                    // Trigger initial resize
                    const ta = item.querySelector('textarea');
                    setTimeout(() => {
                        ta.style.height = 'auto';
                        ta.style.height = ta.scrollHeight + 'px';
                    }, 0);
                }
                
            }, 1000);
        }

        // 2. Generate Images
        function generateAndLoadImages() {
             const btn = document.querySelector('#card-script-review button.primary');
             
             // Gather script from list
             const textareas = document.querySelectorAll('#scriptListContainer .script-textarea');
             const lines = Array.from(textareas).map((ta, i) => `[Shot ${i+1}] ${ta.value}`);
             const promptVal = lines.join('\n\n');
             
             if (!promptVal || lines.length === 0) {
                 alert("è¯·å…ˆç¡®è®¤è„šæœ¬å†…å®¹");
                 return;
             }

             const originalText = btn.innerText;
             btn.innerText = "ğŸ¨ ç»˜ç”»ä¸­...";
             btn.disabled = true;

             // Simulate generation delay
             setTimeout(() => {
                 btn.innerText = originalText;
                 btn.disabled = false;
                 
                 console.log("Generating images using script:", promptVal);

                 // Show Step 4 (Workspace)
                 const stepWorkspace = document.getElementById('step-workspace');
                 stepWorkspace.classList.remove('step-hidden');
                 stepWorkspace.scrollIntoView({ behavior: 'smooth', block: 'start' });
                 
                 generateDemoGrid();
             }, 1000);
        }

        // ================= SESSION MANAGEMENT SYSTEM =================
        let sessions = []; 
        let activeSessionId = null;
        let globalSelectedList = []; // Array of { instanceId, sessionId, tileId, src, badge }
        
        let selectedListSortable = null;
        let gridSortable = null;

        function generateInstanceId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2);
        }

        function rebuildGlobalSelectedList() {
            // Since we allow duplicates, rebuilding from session.selectedList is tricky if we don't store the structure.
            // But session.selectedList was used for syncing. If we decouple, we might not need to rebuild from sessions.
            // However, if we want to persist state per session, we should store the list of selected items (including duplicates) in the session.
            
            // For now, let's assume globalSelectedList is the master truth for the "Selected Slices" sidebar.
            // When switching sessions, maybe we want to keep the sidebar as is (global workspace)? 
            // The user said "Global Selected List" in the code comments ("å½“å‰å…¨å±€å·²é€‰æ‹©").
            // So we just keep globalSelectedList as is.
            renderSelectedList();
        }

        function updateSummary(session) {
            const summaryElement = document.getElementById('summaryText');
            if (!summaryElement) return;
            summaryElement.textContent = "å½“å‰å·²é€‰æ‹© " + globalSelectedList.length + " ä¸ªåˆ‡ç‰‡ã€‚å¯ä»¥ä»å³ä¾§é‡å¤æ‹–æ‹½æˆ–ç‚¹å‡»æ·»åŠ ï¼Œæ‹–æ‹½æ’åºï¼Œå¹¶ä½¿ç”¨ä¸‹æ–¹æŒ‰é’®å¯¼å‡ºå›¾ç‰‡åºåˆ—ã€‚";
        }

        function handleImageUpload(input) {
            if (input.files && input.files[0]) {
                const reader = new FileReader();
                reader.onload = function (e) {
                    loadImageAndCreateSession(e.target.result);
                }
                reader.readAsDataURL(input.files[0]);
                input.value = ''; 
            }
        }

        function handleRefUpload(input, containerId) {
            if (!input.files || input.files.length === 0) return;
            
            const container = document.getElementById(containerId);
            const placeholderId = containerId.replace('Images', 'Placeholder');
            const placeholder = document.getElementById(placeholderId);
            
            if(placeholder) placeholder.classList.add('has-items');
            
            Array.from(input.files).forEach(file => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const div = document.createElement('div');
                    div.className = 'ref-image-item';
                    div.innerHTML = `
                        <img src="${e.target.result}">
                        <div class="ref-image-delete" onclick="event.stopPropagation(); removeRefImage(this, '${placeholderId}')">Ã—</div>
                    `;
                    
                    // Insert before the "Add More" button if it exists
                    const addBtn = container.querySelector('.ref-add-more');
                    if(addBtn) {
                        container.insertBefore(div, addBtn);
                    } else {
                        container.appendChild(div);
                        // Add "Add More" button if not present
                        const newAddBtn = document.createElement('div');
                        newAddBtn.className = 'ref-add-more';
                        newAddBtn.innerHTML = '+';
                        container.appendChild(newAddBtn);
                    }
                }
                reader.readAsDataURL(file);
            });
            
            input.value = ''; 
        }

        function removeRefImage(btn, placeholderId) {
            const item = btn.parentElement;
            const container = item.parentElement;
            item.remove();
            
            // Check if any images remain
            const hasImages = container.querySelectorAll('.ref-image-item').length > 0;
            
            if(!hasImages) {
                const placeholder = document.getElementById(placeholderId);
                if(placeholder) placeholder.classList.remove('has-items');
                
                // Remove add button
                const addBtn = container.querySelector('.ref-add-more');
                if(addBtn) addBtn.remove();
            }
        }

        function generateDemoGrid() {
            const canvas = document.createElement('canvas');
            canvas.width = 1920;
            canvas.height = 1080;
            const ctx = canvas.getContext('2d');
            const w = canvas.width / 5;
            const h = canvas.height / 5;
            
            for (let y = 0; y < 5; y++) {
                for (let x = 0; x < 5; x++) {
                    const hue = (x + y) * 25;
                    ctx.fillStyle = `hsl(${hue}, 70%, 85%)`;
                    ctx.fillRect(x * w, y * h, w, h);
                    ctx.fillStyle = `hsl(${hue}, 70%, 40%)`;
                    ctx.font = 'bold 60px Inter, sans-serif';
                    ctx.fillText(`${y * 5 + x + 1}`, x * w + w / 2 - 20, y * h + h / 2 + 20);
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(x * w, y * h, w, h);
                }
            }
            loadImageAndCreateSession(canvas.toDataURL());
        }

        function loadImageAndCreateSession(src) {
            const img = new Image();
            img.onload = function () {
                const tilesData = performSlicing(img);
                
                const newSession = {
                    id: Date.now(),
                    name: `åˆ‡ç‰‡ç»„ ${sessions.length + 1}`,
                    thumb: src,
                    timestamp: new Date(),
                    tiles: tilesData,
                    // selectedList: [] // Removed as we are using global list
                };
                
                // newSession.selectedList = []; // Start empty until confirmed
                
                sessions.unshift(newSession); 
                activeSessionId = newSession.id;
                
                renderSessionList();
                loadSessionToWorkspace(newSession);
                
                // Show Grid View
                document.getElementById('uploadArea').style.display = 'none';
                document.getElementById('gridContainer').style.display = 'flex';
                document.getElementById('workspaceActions').style.display = 'flex';
                
                // Ensure selected list sortable is initialized even if empty
                renderSelectedList();
            }
            img.src = src;
        }
        
        function performSlicing(img) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const rows = 5;
            const cols = 5;
            
            const imgW = img.naturalWidth;
            const imgH = img.naturalHeight;
            const cellW = imgW / cols;
            const cellH = imgH / rows;
            
            canvas.width = cellW;
            canvas.height = cellH;
            
            const tiles = [];
            
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    ctx.clearRect(0, 0, cellW, cellH);
                    ctx.drawImage(img, c * cellW, r * cellH, cellW, cellH, 0, 0, cellW, cellH);
                    
                    const dataUrl = canvas.toDataURL('image/jpeg', 0.95);
                    const index = r * cols + c;
                    
                    tiles.push({
                        id: index,
                        src: dataUrl,
                        selected: true, // Default to selected
                        badge: `#${index + 1}`
                    });
                }
            }
            return tiles;
        }

        function renderSessionList() {
            const container = document.getElementById('sessionList');
            if(sessions.length === 0) {
                 container.innerHTML = '<div style="text-align: center; color: #94a3b8; padding: 20px; font-size: 0.85rem;">æš‚æ— åˆ‡ç‰‡<br>ä¸Šä¼ å›¾ç‰‡å¼€å§‹</div>';
                 return;
            }
            
            container.innerHTML = '';
            
            sessions.forEach(session => {
                const div = document.createElement('div');
                div.className = `session-item ${session.id === activeSessionId ? 'active' : ''}`;
                div.onclick = () => switchSession(session.id);
                
                const selectedCount = 0; // session.selectedList is removed
                
                div.innerHTML = `
                    <img class="session-thumb" src="${session.thumb}">
                    <div class="session-info">
                        <div>
                            <div style="font-weight:600;">${session.name}</div>
                            <div class="session-meta">${session.timestamp.toLocaleTimeString()}</div>
                        </div>
                        <div class="badge" style="font-size:0.7rem; display:none;">${selectedCount}é€‰</div>
                    </div>
                `;
                container.appendChild(div);
            });
        }
        
        function switchSession(id) {
            activeSessionId = id;
            const session = sessions.find(s => s.id === id);
            if(session) {
                loadSessionToWorkspace(session);
                renderSessionList(); 
                
                // Ensure grid is showing
                document.getElementById('uploadArea').style.display = 'none';
                document.getElementById('gridContainer').style.display = 'flex';
                document.getElementById('workspaceActions').style.display = 'flex';
            }
        }
        
        function loadSessionToWorkspace(session) {
            const grid = document.getElementById('interactiveGrid');
            grid.innerHTML = '';
            
            // Re-render based on current order in session.tiles (if reordered previously)
            // But wait, session.tiles is the source of truth for the grid. 
            // If we allow reordering, we must update session.tiles when drag ends.
            
            session.tiles.forEach(tileData => {
                const div = document.createElement('div');
                div.className = `grid-tile ${tileData.selected ? 'is-selected' : 'is-ignored'}`;
                div.setAttribute('data-id', tileData.id);
                
                div.innerHTML = `
                    <img src="${tileData.src}">
                    <div class="tile-badge">${tileData.badge}</div>
                `;
                
                div.addEventListener('click', function() {
                    tileData.selected = !tileData.selected;
                    
                    if(tileData.selected) {
                        this.classList.remove('is-ignored');
                        this.classList.add('is-selected');
                    } else {
                        this.classList.remove('is-selected');
                        this.classList.add('is-ignored');
                    }
                });
                
                grid.appendChild(div);
            });
            
            initGridSortable();
        }
        
        // addToSelectedList removed as we use confirmSelection now

        function initGridSortable() {
             const el = document.getElementById('interactiveGrid');
             if(gridSortable) gridSortable.destroy();
             
             gridSortable = new Sortable(el, {
                 group: {
                     name: 'shared',
                     pull: 'clone',
                     put: false
                 },
                 animation: 200,
                 ghostClass: 'sortable-ghost',
                 forceFallback: true, 
                 fallbackClass: 'sortable-drag', 
                 fallbackOnBody: true, 
                 swapThreshold: 0.65,
                 delay: 0,
                 onStart: function(evt) {
                     document.getElementById('selectedList').classList.add('highlight-drop-zone');
                 },
                 onEnd: function(evt) {
                     document.getElementById('selectedList').classList.remove('highlight-drop-zone');
                     
                     // Update session.tiles order based on DOM
                     if(!activeSessionId) return;
                     if(evt.to !== el) return; // Only handle internal sorting

                     const session = sessions.find(s => s.id === activeSessionId);
                     if(session) {
                         const newOrderIds = Array.from(el.children).map(child => parseInt(child.getAttribute('data-id')));
                         
                         // Create a new array sorted by the DOM order
                         const newTiles = [];
                         newOrderIds.forEach(id => {
                             const tile = session.tiles.find(t => t.id === id);
                             if(tile) newTiles.push(tile);
                         });
                         session.tiles = newTiles;
                     }
                 }
             });
        }

        function confirmSelection() {
            if(!activeSessionId) return;
            const session = sessions.find(s => s.id === activeSessionId);
            if(!session) return;

            // Identify currently selected tiles in the grid
            const currentSelectedTiles = session.tiles.filter(t => t.selected);
            
            if (currentSelectedTiles.length === 0) {
                // Optional: Alert user or just do nothing
                return;
            }

            // Add selected items to global list (append)
            currentSelectedTiles.forEach(tile => {
                globalSelectedList.push({
                    instanceId: generateInstanceId(),
                    sessionId: session.id,
                    tileId: tile.id,
                    src: tile.src,
                    badge: tile.badge
                });
            });
            
            renderSelectedList();
            updateSummary(session);

            const btn = document.querySelector('#workspaceActions button.primary');
            if (btn) {
                const originalText = btn.innerText;
                btn.innerText = "ğŸ‘Œ å·²æ·»åŠ ";
                setTimeout(() => btn.innerText = originalText, 1000);
            }
            
            // Show Step 5 (Results)
            const stepResults = document.getElementById('step-results');
            if(stepResults && stepResults.classList.contains('step-hidden')) {
                stepResults.classList.remove('step-hidden');
                stepResults.scrollIntoView({ behavior: 'smooth', block: 'end' });
            }
        }
        
        // Removed syncSelectionWithSession function

        function renderSelectedList() {
            const listEl = document.getElementById('selectedList');
            const countBadge = document.getElementById('leftCountBadge');
            
            countBadge.innerText = globalSelectedList.length;
            
            if(globalSelectedList.length === 0) {
                // Added pointer-events: none to ensure the placeholder doesn't block drag-and-drop
                listEl.innerHTML = '<div style="text-align: center; color: #94a3b8; padding: 20px; font-size: 0.85rem; pointer-events: none;">æš‚æ— å·²é€‰<br>ä»å³ä¾§ç‚¹é€‰æ·»åŠ <br><br>å¯æ‹–æ‹½æ’åº</div>';
            } else {
                // Only clear if we are doing a full re-render (which we avoid on delete now)
                listEl.innerHTML = '';
                
                globalSelectedList.forEach((item, index) => {
                    const div = document.createElement('div');
                    div.className = 'selected-item';
                    div.setAttribute('data-id', item.tileId); 
                    div.setAttribute('data-instance-id', item.instanceId); 
                    div.setAttribute('data-key', item.sessionId + '-' + item.tileId);
                    
                    div.innerHTML = `
                        <div class="delete-btn" onclick="removeFromSelection('${item.instanceId}')">Ã—</div>
                        <div class="selected-item-frame">
                            <img src="${item.src}">
                        </div>
                        <div class="tile-badge" style="position:absolute; bottom:4px; left:4px;">#${index + 1}</div>
                    `;
                    listEl.appendChild(div);
                });
            }
            
            initSelectedSortable();
        }

        function removeFromSelection(instanceId) {
            // 1. Update Data
            const itemIndex = globalSelectedList.findIndex(i => i.instanceId === instanceId);
            if (itemIndex === -1) return;
            const item = globalSelectedList[itemIndex];
            globalSelectedList.splice(itemIndex, 1);

            // 2. Update UI (DOM) - Direct removal for stability
            const listEl = document.getElementById('selectedList');
            const itemEl = listEl.querySelector(`[data-instance-id="${instanceId}"]`);
            if (itemEl) {
                itemEl.remove();
            }

            // 3. Update Badge
            document.getElementById('leftCountBadge').innerText = globalSelectedList.length;
            
            // 4. Handle Empty State
            if (globalSelectedList.length === 0) {
                renderSelectedList(); // Re-render to show placeholder
            }

            // 5. Update Session Summary
            const session = sessions.find(s => s.id === item.sessionId);
            if (session) {
                updateSummary(session);
            }
            
            // 6. Update Badges (Sequential Numbering)
            const badges = listEl.querySelectorAll('.selected-item .tile-badge');
            badges.forEach((badge, index) => {
                badge.innerText = `#${index + 1}`;
            });
        }
        
        function initSelectedSortable() {
            if (typeof Sortable === 'undefined') {
                 console.warn('SortableJS failed to load'); 
                 return;
            }
            const el = document.getElementById('selectedList');
            if(selectedListSortable) selectedListSortable.destroy();
            
            selectedListSortable = new Sortable(el, {
                group: {
                    name: 'shared',
                    pull: false,
                    put: true
                },
                animation: 150,
                ghostClass: 'sortable-ghost',
                forceFallback: true,
                fallbackClass: 'sortable-drag',
                fallbackOnBody: true,
                dataIdAttr: 'data-instance-id', // Use instance ID for sorting
                onAdd: function(evt) {
                    const itemEl = evt.item;
                    const newIndex = evt.newIndex;
                    const tileId = parseInt(itemEl.getAttribute('data-id'));
                    
                    if(isNaN(tileId) || !activeSessionId) {
                        itemEl.remove();
                        return;
                    }

                    const session = sessions.find(s => s.id === activeSessionId);
                    if(!session) {
                        itemEl.remove();
                        return;
                    }
                    
                    const tile = session.tiles.find(t => t.id === tileId);
                    if(!tile) {
                         itemEl.remove();
                         return;
                    }

                    // Remove the dropped clone immediately
                    itemEl.remove();

                    // Always add as new item (allow duplicates)
                    const newItem = {
                        instanceId: generateInstanceId(),
                        sessionId: session.id,
                        tileId: tile.id,
                        src: tile.src,
                        badge: tile.badge
                    };
                    
                    globalSelectedList.splice(newIndex, 0, newItem);
                    
                    renderSelectedList();
                    updateSummary(session);
                },
                onEnd: function(evt) {
                    // Reorder based on DOM
                    const newOrderInstanceIds = Array.from(el.children).map(child => child.getAttribute('data-instance-id'));
                    
                    const newGlobalList = [];
                    newOrderInstanceIds.forEach(instanceId => {
                        const item = globalSelectedList.find(i => i.instanceId === instanceId);
                        if(item) newGlobalList.push(item);
                    });
                    
                    globalSelectedList = newGlobalList;
                    
                    // Re-render to update numbering
                    renderSelectedList();
                }
            });
        }

        function resetWorkspace() {
             if(confirm("ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰å†å²è®°å½•å—ï¼Ÿ")) {
                 sessions = [];
                 activeSessionId = null;
                 globalSelectedList = [];
                 
                 document.getElementById('gridContainer').style.display = 'none';
                 document.getElementById('workspaceActions').style.display = 'none';
                 document.getElementById('uploadArea').style.display = 'flex';
                 
                 renderSelectedList();
                 renderSessionList();
             }
        }
        
        function exportSelectedList() {
            if(globalSelectedList.length === 0) {
                alert("å·¦ä¾§å·²é€‰åˆ—è¡¨ä¸ºç©ºï¼");
                return;
            }
            
            const zip = new JSZip();
            const folder = zip.folder("Selected_Export");
            
            globalSelectedList.forEach((item, index) => {
                const base64Data = item.src.split(',')[1];
                const fileName = `Sequence_${String(index+1).padStart(3, '0')}.jpg`;
                folder.file(fileName, base64Data, {base64: true});
            });
            
            zip.generateAsync({type:"blob"})
            .then(function(content) {
                saveAs(content, "Selected_Global.zip");
            });
        }
/* Removed fillPresetScript and fillPresetSegment as they are replaced by prompt config */

        /* ================= COLLAGE SYSTEM ================= */
        let collageDragSrc = null;

        function openCollageModal() {
            const modal = document.getElementById('collageModal');
            modal.classList.add('active');
            renderCollageSourceList();
            
            // Determine initial grid size based on image count
            const count = globalSelectedList.length;
            let size = "3x3"; // Default
            
            if (count <= 4) size = "2x2";
            else if (count <= 6) size = "2x3";
            else if (count <= 9) size = "3x3";
            else if (count <= 16) size = "4x4";
            else size = "5x5"; // Up to 25
            
            document.getElementById('collageGridSelect').value = size;
            
            // Update grid and auto-fill images
            updateCollageGrid(true);
        }

        function closeCollageModal() {
            document.getElementById('collageModal').classList.remove('active');
        }

        function renderCollageSourceList() {
            const container = document.getElementById('collageSourceList');
            container.innerHTML = '';
            
            globalSelectedList.forEach((item, index) => {
                const div = document.createElement('div');
                div.className = 'source-item';
                div.draggable = true;
                div.ondragstart = (e) => handleCollageDragStart(e, item.src);
                div.innerHTML = `
                    <img src="${item.src}">
                    <div class="tile-badge" style="position:absolute; bottom:4px; left:4px;">#${index + 1}</div>
                `;
                container.appendChild(div);
            });
        }

        function updateCollageGrid(shouldAutoFill = false) {
            const size = document.getElementById('collageGridSelect').value;
            const [rows, cols] = size.split('x').map(Number);
            const container = document.getElementById('collageContainer');
            
            container.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
            
            // Calculate existing cells to preserve content if possible
            const currentCells = Array.from(container.children);
            const totalCells = rows * cols;
            
            container.innerHTML = '';
            
            for(let i=0; i<totalCells; i++) {
                const cell = document.createElement('div');
                cell.className = 'collage-cell';
                cell.draggable = true;
                cell.ondragover = allowDrop;
                cell.ondrop = handleCollageDrop;
                cell.ondragstart = handleCellDragStart;
                
                // Try to preserve content from previous grid if resizing
                // Only if NOT auto-filling
                if(!shouldAutoFill && i < currentCells.length && currentCells[i].querySelector('img')) {
                    cell.innerHTML = currentCells[i].innerHTML;
                }
                
                container.appendChild(cell);
            }

            if (shouldAutoFill) {
                const cells = Array.from(container.children);
                // Fill cells with globalSelectedList images sequentially
                for(let i = 0; i < cells.length && i < globalSelectedList.length; i++) {
                    const item = globalSelectedList[i];
                    cells[i].innerHTML = `<img src="${item.src}" style="pointer-events: none; width: 100%; height: 100%; object-fit: cover;">`;
                }
            }
        }

        function handleCollageDragStart(e, src) {
            collageDragSrc = { type: 'source', src: src };
            e.dataTransfer.effectAllowed = 'copy';
        }
        
        function handleCellDragStart(e) {
            const img = e.target.querySelector('img');
            if(!img) {
                e.preventDefault();
                return;
            }
            collageDragSrc = { type: 'cell', src: img.src, cell: e.target };
            e.dataTransfer.effectAllowed = 'move';
        }

        function allowDrop(e) {
            e.preventDefault();
        }

        function handleCollageDrop(e) {
            e.preventDefault();
            const cell = e.target.closest('.collage-cell');
            if(!cell || !collageDragSrc) return;
            
            // If dropping on itself
            if(collageDragSrc.type === 'cell' && collageDragSrc.cell === cell) return;
            
            const newSrc = collageDragSrc.src;
            
            // If swapping cells
            if(collageDragSrc.type === 'cell') {
                const sourceCell = collageDragSrc.cell;
                const targetImg = cell.querySelector('img');
                
                // Move target image to source cell (swap)
                if(targetImg) {
                    sourceCell.innerHTML = `<img src="${targetImg.src}" style="pointer-events: none; width: 100%; height: 100%; object-fit: cover;">`;
                } else {
                    sourceCell.innerHTML = '';
                }
            }
            
            cell.innerHTML = `<img src="${newSrc}" style="pointer-events: none; width: 100%; height: 100%; object-fit: cover;">`;
            collageDragSrc = null;
        }

        function exportCollageImage() {
            const container = document.getElementById('collageContainer');
            const cells = Array.from(container.children);
            const size = document.getElementById('collageGridSelect').value;
            const [rows, cols] = size.split('x').map(Number);
            
            if(cells.every(c => !c.querySelector('img'))) {
                alert("è¯·å…ˆæ‹–å…¥å›¾ç‰‡ï¼");
                return;
            }
            
            // Setup Canvas
            const canvas = document.createElement('canvas');
            const tileW = 1280; // High res base width
            const tileH = tileW * (9/16);
            
            canvas.width = cols * tileW;
            canvas.height = rows * tileH;
            const ctx = canvas.getContext('2d');
            
            // Draw Background (White)
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            let loadedCount = 0;
            const imagesToDraw = [];
            
            cells.forEach((cell, index) => {
                const img = cell.querySelector('img');
                if(img) {
                    imagesToDraw.push({
                        src: img.src,
                        row: Math.floor(index / cols),
                        col: index % cols
                    });
                }
            });
            
            if(imagesToDraw.length === 0) return;
            
            // Helper to load image
            const loadAndDraw = (item) => {
                return new Promise((resolve) => {
                    const image = new Image();
                    image.crossOrigin = "anonymous"; // Try to handle potential CORS
                    image.onload = () => {
                        ctx.drawImage(image, item.col * tileW, item.row * tileH, tileW, tileH);
                        resolve();
                    };
                    image.onerror = () => {
                         console.warn("Failed to load image for canvas:", item.src);
                         resolve(); // Skip but resolve
                    };
                    image.src = item.src;
                });
            };
            
            const btn = document.querySelector('#collageModal .primary');
            const originalText = btn.innerText;
            btn.innerText = "ç”Ÿæˆä¸­...";
            btn.disabled = true;
            
            Promise.all(imagesToDraw.map(loadAndDraw)).then(() => {
                canvas.toBlob((blob) => {
                    saveAs(blob, `Collage_${size}_${Date.now()}.png`);
                    btn.innerText = originalText;
                    btn.disabled = false;
                });
            });
        }
    </script>
</body>
</html>
