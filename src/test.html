<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini Flow | é«˜æ•ˆä¸€è‡´æ€§å·¥ä½œæµ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
    <style>
        :root {
            /* ç°ä»£è°ƒè‰²æ¿ (Slate & Indigo) */
            --primary: #6366f1;
            /* ä¸»è‰²è°ƒ Indigo-500 */
            --primary-hover: #4f46e5;
            /* Indigo-600 */
            --bg-body: #f8fafc;
            /* Slate-50 */
            --bg-card: #ffffff;
            /* White */
            --text-main: #1e293b;
            /* Slate-800 */
            --text-sub: #64748b;
            /* Slate-500 */
            --border: #e2e8f0;
            /* Slate-200 */
            --input-bg: #f1f5f9;
            /* Slate-100 */
            --success: #10b981;
            /* Emerald */
            --danger: #ef4444;
            /* Red */

            --radius-lg: 16px;
            --radius-md: 12px;
            --radius-sm: 8px;

            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-body);
            color: var(--text-main);
            margin: 0;
            height: 100vh;
            overflow: hidden;
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
            display: flex;
            flex-direction: column;
        }

        /* é¡¶éƒ¨å¯¼èˆª */
        header {
            background: white;
            border-bottom: 1px solid var(--border);
            padding: 0 24px;
            z-index: 100;
            flex-shrink: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 60px;
            box-sizing: border-box;
        }

        h1 {
            margin: 0;
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--text-main);
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .badge {
            background: #e0e7ff;
            color: var(--primary);
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Main 3-Column Layout */
        .app-layout {
            display: grid;
            grid-template-columns: 280px 1fr 280px;
            flex-grow: 1;
            overflow: hidden;
            height: calc(100vh - 60px);
        }

        /* Sidebar Styles */
        .sidebar {
            background: white;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border-right: 1px solid var(--border);
        }

        .sidebar.right {
            border-right: none;
            border-left: 1px solid var(--border);
        }

        .sidebar-header {
            padding: 16px;
            background: #f8fafc;
            border-bottom: 1px solid var(--border);
            font-weight: 600;
            color: var(--text-main);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .sidebar-content {
            flex: 1;
            overflow-y: scroll;
            /* Force scrollbar to prevent layout shift */
            /* scrollbar-gutter: stable; */
            padding: 0;
            background: #f1f5f9;
            display: block;
        }

        /* Custom Scrollbar for Sidebar to look cleaner */
        .sidebar-content::-webkit-scrollbar {
            width: 6px;
        }

        .sidebar-content::-webkit-scrollbar-track {
            background: transparent;
        }

        .sidebar-content::-webkit-scrollbar-thumb {
            background-color: #cbd5e1;
            border-radius: 3px;
        }

        .sidebar-content::-webkit-scrollbar-thumb:hover {
            background-color: #94a3b8;
        }

        .sidebar-footer {
            padding: 12px;
            background: white;
            border-top: 1px solid var(--border);
            flex-shrink: 0;
        }

        /* Center Column Styles */
        .center-column {
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            padding: 24px;
            gap: 24px;
            background: var(--bg-body);
        }

        /* Cards */
        .card {
            background: var(--bg-card);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--border);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        .card.flex-grow {
            flex-grow: 1;
            min-height: 400px;
        }

        .card-header {
            padding: 16px 24px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            background: #fafafa;
        }

        .step-icon {
            width: 28px;
            height: 28px;
            background: var(--primary);
            color: white;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9rem;
            margin-right: 12px;
            box-shadow: 0 2px 4px rgba(99, 102, 241, 0.2);
        }

        .card-title {
            font-size: 1rem;
            font-weight: 600;
        }

        .card-body {
            padding: 24px;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }

        /* Textarea */
        textarea {
            width: 100%;
            height: 100px;
            padding: 12px;
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            background: var(--input-bg);
            font-family: inherit;
            font-size: 0.95rem;
            color: var(--text-main);
            box-sizing: border-box;
            resize: vertical;
            outline: none;
        }

        textarea:focus {
            border-color: var(--primary);
            background: white;
        }

        /* JSON Output */
        .code-block {
            background: #1e293b;
            color: #e2e8f0;
            border-radius: var(--radius-md);
            padding: 16px;
            font-family: 'Menlo', 'Monaco', monospace;
            font-size: 0.85rem;
            margin-top: 16px;
            max-height: 200px;
            overflow-y: auto;
            white-space: pre-wrap;
            display: none;
            border: 1px solid #334155;
        }

        /* Buttons */
        button {
            cursor: pointer;
            border: none;
            font-size: 0.9rem;
            font-weight: 600;
            padding: 8px 16px;
            border-radius: var(--radius-sm);
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        button.primary {
            background-color: var(--primary);
            color: white;
        }

        button.primary:hover {
            background-color: var(--primary-hover);
        }

        button.secondary {
            background-color: white;
            border: 1px solid var(--border);
            color: var(--text-main);
        }

        button.secondary:hover {
            background-color: var(--input-bg);
        }

        button.danger-ghost {
            background: transparent;
            color: var(--text-sub);
            padding: 4px;
        }

        button.danger-ghost:hover {
            color: var(--danger);
            background: #fee2e2;
        }

        /* Upload Zone */
        .upload-zone {
            border: 2px dashed var(--border);
            border-radius: var(--radius-lg);
            padding: 40px;
            text-align: center;
            background: #fdfdfd;
            transition: all 0.2s;
            position: relative;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .upload-zone:hover {
            border-color: var(--primary);
            background: #f0fdfa;
        }

        .upload-zone input {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            opacity: 0;
            cursor: pointer;
        }

        /* Interactive Grid */
        .grid-container {
            display: none;
            /* Initially hidden */
            flex-direction: column;
            height: 100%;
        }

        .interactive-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 4px;
            background: #e2e8f0;
            padding: 4px;
            border-radius: var(--radius-md);
        }

        .grid-tile {
            position: relative;
            aspect-ratio: 16/9;
            cursor: grab;
            overflow: hidden;
            border-radius: 4px;
            background: white;
            transition: all 0.2s ease;
            user-select: none;
        }

        .grid-tile:active {
            cursor: grabbing;
        }

        .grid-tile img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
            pointer-events: none;
        }

        .grid-tile.is-selected {
            opacity: 1;
            filter: grayscale(0%);
            border: 2px solid var(--primary);
            z-index: 1;
        }

        .grid-tile.is-ignored {
            opacity: 0.4;
            filter: grayscale(100%);
            transform: scale(0.95);
            border: 2px solid transparent;
        }

        .tile-badge {
            position: absolute;
            top: 4px;
            left: 4px;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 4px;
        }

        /* Sidebar Items */
        .selected-item {
            position: relative;
            background: white;
            /* Remove border-radius and margin to make them stack seamlessly */
            border-radius: 0;
            overflow: hidden;
            /* Remove border and shadow */
            border: none;
            border-bottom: 1px solid white;
            /* Add thin white line separator */
            box-shadow: none;
            display: block;
            /* Changed to block */
            cursor: grab;
            margin-bottom: 0;
            transition: all 0.2s;
        }

        .selected-item:hover .delete-btn {
            opacity: 1;
        }

        .delete-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 28px;
            height: 28px;
            background: rgba(255, 255, 255, 0.95);
            color: #ef4444;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            opacity: 0;
            transition: all 0.2s;
            z-index: 50;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .delete-btn:hover {
            background: #fff;
            transform: scale(1.1);
            color: #dc2626;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.15);
        }

        .selected-item-frame {
            /* Ensure frame takes full width */
            width: 100%;
            background: #000;
            /* Force reset any potential height constraints */
            height: auto;
            min-height: 0;
            display: block;
            line-height: 0;
            /* Remove potential text line-height gaps */
        }

        .selected-item-frame img {
            width: 100%;
            height: auto;
            display: block;
            vertical-align: top;
            /* Changed from bottom to top to be safe */
            border: none;
            margin: 0;
            padding: 0;
        }

        .selected-item-info {
            display: none;
            /* Hide the info bar as per screenshot */
        }

        .selected-item:last-child {
            border-bottom: none;
        }

        .session-item {
            background: white;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
            display: flex;
            flex-direction: column;
        }

        .session-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .session-item.active {
            border-color: var(--primary);
            ring: 2px solid rgba(99, 102, 241, 0.2);
        }

        .session-thumb {
            width: 100%;
            aspect-ratio: 16/9;
            object-fit: cover;
            background: #e2e8f0;
            border-bottom: 1px solid #f1f5f9;
        }

        .session-info {
            padding: 8px 12px;
            font-size: 0.85rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .session-meta {
            color: var(--text-sub);
            font-size: 0.75rem;
        }

        .sortable-ghost {
            opacity: 1 !important;
            background: #f1f5f9 !important;
            border: 2px dashed var(--primary) !important;
            box-shadow: none !important;
            transform: none !important;
            filter: none !important;
        }

        .sortable-ghost img,
        .sortable-ghost .tile-badge {
            opacity: 0.5 !important;
            visibility: visible !important;
            filter: grayscale(100%) !important;
        }

        .sortable-drag {
            cursor: grabbing;
            opacity: 1 !important;
            /* transform: scale(1.05); */
            z-index: 9999;
            box-shadow: 0 25px 50px -12px rgb(0 0 0 / 0.25);
            border-radius: var(--radius-md);
            border: 1px solid var(--primary);
            pointer-events: none !important;
            /* Critical for drag detection */
            transition: none !important;
            /* Critical: prevent lag during drag */
        }

        /* Drop Zone Highlight */
        .highlight-drop-zone {
            background-color: #f0fdfa !important;
            /* Light teal/blue background */
            box-shadow: inset 0 0 0 2px var(--primary);
            transition: all 0.3s ease;
        }

        /* ================= CHAT UI STYLES ================= */
        .chat-stream {
            display: flex;
            flex-direction: column;
            gap: 32px;
            padding-bottom: 60px;
        }

        .chat-message {
            display: flex;
            gap: 16px;
            opacity: 0;
            animation: fadeIn 0.5s forwards;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .chat-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            flex-shrink: 0;
            box-shadow: 0 4px 6px -1px rgba(99, 102, 241, 0.3);
        }

        .chat-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-width: 100%;
        }

        .chat-name {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-sub);
            margin-left: 4px;
        }

        /* Override Card for Chat Bubble look */
        .chat-bubble {
            background: white;
            border-radius: 0 16px 16px 16px;
            box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border: 1px solid var(--border);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .chat-bubble.user-bubble {
            border-radius: 16px 0 16px 16px;
            background: #eff6ff;
            border-color: #bfdbfe;
        }

        /* Script Item Styles */
        .script-item {
            background: white;
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            padding: 16px;
            display: flex;
            gap: 16px;
            transition: all 0.2s;
        }

        .script-item:hover {
            border-color: var(--primary);
            box-shadow: var(--shadow-sm);
        }

        .shot-badge {
            background: #e0e7ff;
            color: var(--primary);
            font-weight: 700;
            font-size: 0.85rem;
            padding: 4px 8px;
            border-radius: 6px;
            height: fit-content;
            flex-shrink: 0;
            white-space: nowrap;
        }

        .script-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .script-textarea {
            width: 100%;
            min-height: 60px;
            padding: 8px;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 0.9rem;
            resize: none;
            overflow-y: hidden;
            font-family: inherit;
            background: #f8fafc;
        }

        .script-textarea:focus {
            background: white;
            border-color: var(--primary);
            outline: none;
        }

        /* Hide steps initially */
        .step-hidden {
            display: none !important;
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: white;
            border-radius: var(--radius-lg);
            width: 600px;
            max-width: 90%;
            box-shadow: var(--shadow-lg);
            display: flex;
            flex-direction: column;
            transform: translateY(20px);
            transition: transform 0.2s;
        }

        .modal-overlay.active .modal {
            transform: translateY(0);
        }

        .modal-header {
            padding: 16px 24px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            font-size: 1.1rem;
        }

        .modal-body {
            padding: 24px;
        }

        .modal-footer {
            padding: 16px 24px;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            background: #f8fafc;
            border-radius: 0 0 var(--radius-lg) var(--radius-lg);
        }

        /* Improved Ref Upload Styles */
        .ref-drop-zone {
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            padding: 20px;
            background: #fafafa;
            transition: all 0.2s;
            min-height: 120px;
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: center;
            cursor: pointer;
            position: relative;
        }

        .ref-drop-zone:hover,
        .ref-drop-zone.drag-over {
            border-color: var(--primary);
            background: #f0f9ff;
        }

        .ref-placeholder {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: var(--text-sub);
            pointer-events: none;
            transition: all 0.2s;
        }

        .ref-placeholder.has-items {
            display: none;
        }

        /* Icon removed */

        .ref-image-item {
            width: 80px;
            height: 80px;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            border: 1px solid var(--border);
            box-shadow: var(--shadow-sm);
            flex-shrink: 0;
            animation: fadeIn 0.3s ease;
            background: white;
        }

        .ref-image-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .ref-image-delete {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 20px;
            height: 20px;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.2s;
            cursor: pointer;
            z-index: 2;
        }

        .ref-image-item:hover .ref-image-delete {
            opacity: 1;
        }

        .ref-add-more {
            width: 80px;
            height: 80px;
            border-radius: 8px;
            border: 1px dashed var(--primary);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--primary);
            background: rgba(99, 102, 241, 0.05);
            font-size: 24px;
            flex-shrink: 0;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.9);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }
    </style>
</head>

<body>

    <header>
        <h1>
            <span style="font-size: 24px;">ğŸ’</span>
            Gemini Workflow
            <span class="badge">v2.1 Layout</span>
        </h1>
        <!-- Print Button removed -->
    </header>

    <div class="app-layout">

        <!-- LEFT COLUMN: Selected Slices -->
        <aside class="sidebar">
            <div class="sidebar-header" style="gap: 8px;">
                <span>ğŸ¬ å·²é€‰åˆ†é•œ</span>
                <div style="margin-left:auto; display:flex; align-items:center; gap:8px;">
                    <span class="badge" id="leftCountBadge">0</span>
                    <button class="secondary" onclick="clearSelectedList()" style="padding: 4px 8px; font-size: 0.8rem;"
                        title="æ¸…ç©ºå·²é€‰">ğŸ—‘ï¸</button>
                </div>
            </div>
            <div class="sidebar-content" id="selectedList">
                <div style="text-align: center; color: #94a3b8; padding: 20px; font-size: 0.85rem;">
                    ä»ä¸­é—´ç‚¹å‡»å›¾ç‰‡<br>æ·»åŠ åˆ°æ­¤å¤„<br><br>å¯æ‹–æ‹½æ’åº
                </div>
            </div>
            <div class="sidebar-footer">
                <button class="primary" style="width: 100%;" onclick="exportSelectedList()">ğŸ“¦ å¯¼å‡ºå·²é€‰</button>
            </div>
        </aside>

        <!-- CENTER COLUMN: Main Work Area -->
        <main class="center-column">

            <div class="chat-stream">

                <!-- Step 1: Script Splitting -->
                <div class="chat-message" id="step-split">
                    <div class="chat-avatar">ğŸ¤–</div>
                    <div class="chat-content">
                        <div class="chat-name">AI Agent</div>
                        <div class="chat-bubble" id="card-split">
                            <div class="card-header" style="justify-content: space-between;">
                                <span class="card-title">åˆ†é•œè„šæœ¬ (AI Analysis)</span>
                                <button class="secondary" style="padding: 4px 8px; font-size: 0.8rem;"
                                    onclick="openPromptModal('split')">âš™ï¸ é¢„è®¾æç¤ºè¯</button>
                            </div>
                            <div class="card-body" style="flex-grow: 0;">
                                <p style="margin-top:0; margin-bottom:12px; font-size:0.9rem; color:var(--text-sub);">
                                    ä½ å¥½ï¼æˆ‘æ˜¯ä½ çš„åˆ†é•œåŠ©æ‰‹ã€‚è¯·å…ˆç²˜è´´ä½ çš„é•¿ç¯‡å‰§æœ¬ï¼Œæˆ‘ä¼šå¸®ä½ æ‹†åˆ†æˆå…³é”®åœºæ™¯ã€‚
                                </p>
                                <textarea id="fullScriptInput" placeholder="åœ¨æ­¤ç²˜è´´é•¿ç¯‡å‰§æœ¬ï¼ˆçº¦5000å­—ï¼‰..."
                                    style="min-height: 150px; overflow-y: hidden; resize: none;"
                                    oninput="autoResize(this, 80)"></textarea>
                                <div style="margin-top: 12px; display: flex; justify-content: flex-end;">
                                    <button class="primary" onclick="splitScript()">ğŸ¤– AI æ™ºèƒ½æ‹†åˆ†</button>
                                </div>

                                <!-- Split Results Area -->
                                <div id="splitResults"
                                    style="margin-top: 16px; display: none; gap: 12px; flex-direction: column;">
                                    <!-- Results will be injected here -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Step 2: Script Generation (Initially Hidden) -->
                <div class="chat-message step-hidden" id="step-input">
                    <div class="chat-avatar">ğŸ¤–</div>
                    <div class="chat-content">
                        <div class="chat-name">AI Agent</div>
                        <div class="chat-bubble" id="card-input">
                            <div class="card-header" style="justify-content: space-between;">
                                <span class="card-title">ç‰‡æ®µé€‰å– (Segment Selection)</span>
                                <button class="secondary" style="padding: 4px 8px; font-size: 0.8rem;"
                                    onclick="openPromptModal('shot')">âš™ï¸ é¢„è®¾æç¤ºè¯</button>
                            </div>
                            <div class="card-body" style="flex-grow: 0;">
                                <p style="margin-top:0; margin-bottom:12px; font-size:0.9rem; color:var(--text-sub);">
                                    å·²æå–è¯¥ç‰‡æ®µã€‚ä½ å¯ä»¥ä¿®æ”¹ç‰‡æ®µæè¿°ï¼Œç„¶åç‚¹å‡»ç”Ÿæˆè„šæœ¬ã€‚
                                </p>
                                <textarea id="scriptInput" placeholder="è¾“å…¥æ‚¨çš„ç‰‡æ®µæè¿°... æˆ–ä»ä¸Šæ–¹æ‹†åˆ†ç»“æœä¸­é€‰æ‹©"
                                    style="overflow-y: hidden; min-height: 100px; resize: none;"
                                    oninput="autoResize(this, 100)"></textarea>

                                <!-- Reference Images Upload -->
                                <div id="sceneRefDropZone" class="ref-drop-zone">
                                    <div class="ref-placeholder" id="sceneRefPlaceholder">
                                        <span style="font-size: 0.85rem;">è¯·ä¸Šä¼ åœºæ™¯å‚è€ƒå›¾ (ç‚¹å‡»æˆ–æ‹–æ‹½ä¸Šä¼ )</span>
                                    </div>
                                    <div id="sceneRefImages" style="display: contents;"></div>
                                    <input type="file" multiple accept="image/*" id="sceneRefUpload"
                                        style="display: none;" onchange="handleRefUpload(this, 'sceneRefImages')">
                                </div>

                                <div style="margin-top: 12px; display: flex; justify-content: flex-end; gap: 10px;">
                                    <button class="primary" onclick="generatePrompts()">âœ¨ ç”Ÿæˆåˆ†é•œè„šæœ¬</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Step 3: Script Review -->
                <div class="chat-message step-hidden" id="step-script-review">
                    <div class="chat-avatar">ğŸ¤–</div>
                    <div class="chat-content">
                        <div class="chat-name">AI Agent</div>
                        <div class="chat-bubble" id="card-script-review">
                            <div class="card-header">
                                <span class="card-title">è„šæœ¬ç¡®è®¤ (Script Confirmation)</span>
                            </div>
                            <div class="card-body" style="flex-grow: 0;">
                                <p style="margin-top:0; margin-bottom:12px; font-size:0.9rem; color:var(--text-sub);">
                                    åˆ†é•œè„šæœ¬å·²ç”Ÿæˆã€‚è¯·æ£€æŸ¥å¹¶è¿›è¡ŒäºŒæ¬¡ä¿®æ”¹ï¼Œç¡®è®¤æ— è¯¯åç”Ÿæˆç”»é¢ã€‚
                                </p>

                                <!-- Script List Container -->
                                <div id="scriptListContainer"
                                    style="display: flex; flex-direction: column; gap: 12px; max-height: 600px; overflow-y: auto; padding-right: 4px;">
                                    <!-- Items will be injected here -->
                                    <div style="text-align: center; color: var(--text-sub); padding: 20px;">ç­‰å¾…ç”Ÿæˆ...
                                    </div>
                                </div>

                                <!-- Reference Images Upload (Script Step) -->
                                <div id="scriptRefDropZone" class="ref-drop-zone">
                                    <div class="ref-placeholder" id="scriptRefPlaceholder">
                                        <span style="font-size: 0.85rem;">ä¸Šä¼ è§’è‰²å’Œåœºæ™¯å‚è€ƒå›¾ (ç‚¹å‡»æˆ–æ‹–æ‹½ä¸Šä¼ )</span>
                                    </div>
                                    <div id="scriptRefImages" style="display: contents;"></div>
                                    <input type="file" multiple accept="image/*" id="scriptRefUpload"
                                        style="display: none;" onchange="handleRefUpload(this, 'scriptRefImages')">
                                </div>

                                <div style="margin-top: 12px; display: flex; justify-content: flex-end; gap: 10px;">
                                    <button class="primary" onclick="generateAndLoadImages()">ğŸ¨ ç”Ÿæˆåˆ†é•œç”»é¢</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Step 4: Interactive Workspace (Old Step 3) -->
                <div class="chat-message step-hidden" id="step-workspace">
                    <div class="chat-avatar">ğŸ¤–</div>
                    <div class="chat-content">
                        <div class="chat-name">AI Agent</div>
                        <div class="chat-bubble flex-grow" id="card-workspace" style="min-height: 500px;">
                            <div class="card-header" style="justify-content: space-between;">
                                <div style="display:flex; align-items:center;">
                                    <span class="card-title">äº¤äº’å¼å·¥ä½œå°</span>
                                </div>
                                <div id="workspaceActions" style="display:none; gap: 8px;">
                                    <button class="primary" onclick="confirmSelection()">âœ… ç¡®è®¤é€‰æ‹©</button>
                                    <button class="secondary" onclick="document.getElementById('imageUpload').click()"
                                        style="padding: 6px 12px; font-size: 0.8rem;">â• æœ¬åœ°å¯¼å…¥</button>
                                </div>
                            </div>
                            <div class="card-body" style="padding: 0; position: relative;">

                                <!-- View 1: Upload -->
                                <div class="upload-zone" id="uploadArea">
                                    <input type="file" id="imageUpload" accept="image/*"
                                        onchange="handleImageUpload(this)">
                                    <div style="font-size: 2rem; margin-bottom: 10px;">ğŸ“‚</div>
                                    <div style="font-weight: 600; margin-bottom: 4px;">ç‚¹å‡»ä¸Šä¼ å›¾ç‰‡</div>
                                    <div style="color: var(--text-sub); font-size: 0.85rem;">æˆ–æ‹–æ‹½æ–‡ä»¶åˆ°æ­¤å¤„</div>
                                </div>

                                <!-- View 2: Grid -->
                                <div class="grid-container" id="gridContainer">
                                    <div id="interactiveGrid" class="interactive-grid"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Step 5: Results (Old Step 4) -->
                <div class="chat-message step-hidden" id="step-results">
                    <div class="chat-avatar">ğŸ¤–</div>
                    <div class="chat-content">
                        <div class="chat-name">AI Agent</div>
                        <div class="chat-bubble" id="card-results">
                            <div class="card-header">
                                <span class="card-title">ç»“æœä¸è¯´æ˜</span>
                            </div>
                            <div class="card-body" style="flex-grow: 0;">
                                <div id="summaryText" style="font-size:0.9rem; color: var(--text-sub);">
                                    åœ¨è¿™é‡Œå¯ä»¥çœ‹åˆ°ä½ åœ¨å·¥ä½œå°ä¸­çš„é€‰æ‹©ç»“æœä¸ç®€å•è¯´æ˜ã€‚
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

            </div>
        </main>

        <!-- RIGHT COLUMN: History -->
        <aside class="sidebar right">
            <div class="sidebar-header" style="justify-content: space-between;">
                <span>ğŸ•˜ å†å²è®°å½•</span>
                <button class="secondary" style="padding: 4px 8px; font-size: 0.8rem;" onclick="createEmptySession()"
                    title="æ–°å»ºè®°å½•">ï¼‹</button>
            </div>
            <div class="sidebar-content" id="sessionList">
                <div style="text-align: center; color: #94a3b8; padding: 20px; font-size: 0.85rem;">
                    æš‚æ— åˆ‡ç‰‡
                </div>
            </div>
        </aside>

    </div>

    <!-- Modal for Prompt Config -->
    <div class="modal-overlay" id="promptModal">
        <div class="modal">
            <div class="modal-header">
                <span>âš™ï¸ é…ç½®é¢„è®¾æç¤ºè¯</span>
                <button class="danger-ghost" onclick="closeModal()">Ã—</button>
            </div>
            <div class="modal-body">
                <p style="margin-top: 0; color: var(--text-sub); font-size: 0.9rem; margin-bottom: 12px;">
                    ä¿®æ”¹å‘é€ç»™ AI çš„ç³»ç»Ÿæç¤ºè¯ï¼ˆSystem Promptï¼‰ã€‚è¿™å°†å½±å“ç”Ÿæˆç»“æœçš„é£æ ¼å’Œæ ¼å¼ã€‚
                </p>
                <textarea id="promptConfigInput" style="height: 200px; font-family: monospace; font-size: 0.85rem;"
                    placeholder="è¾“å…¥ç³»ç»Ÿæç¤ºè¯..."></textarea>
            </div>
            <div class="modal-footer">
                <button class="secondary" onclick="closeModal()">å–æ¶ˆ</button>
                <button class="primary" onclick="savePrompt()">ğŸ’¾ ä¿å­˜ä¿®æ”¹</button>
            </div>
        </div>
    </div>

    <script>
        function initRefDragAndDrop(dropZoneId, fileInputId) {
            const dropZone = document.getElementById(dropZoneId);
            const fileInput = document.getElementById(fileInputId);

            if (!dropZone || !fileInput) return;

            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, preventDefaults, false);
            });

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            ['dragenter', 'dragover'].forEach(eventName => {
                dropZone.addEventListener(eventName, highlight, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, unhighlight, false);
            });

            function highlight(e) {
                dropZone.style.backgroundColor = '#f1f5f9';
                dropZone.style.borderColor = '#94a3b8';
            }

            function unhighlight(e) {
                dropZone.style.backgroundColor = '#fafafa';
                dropZone.style.borderColor = 'var(--border)';
            }

            dropZone.addEventListener('drop', handleDrop, false);

            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;

                // Manually trigger the handler since we can't easily set files to input (security restriction in some browsers, 
                // but we can pass the file list directly to our handler)
                // However, we can create a mock object that looks like an input element
                if (files && files.length > 0) {
                    handleRefUpload({ files: files, value: '' }, dropZone.querySelector('div[id$="RefImages"]').id);
                }
            }

            // Allow clicking anywhere in the box to trigger upload (except on existing images)
            dropZone.addEventListener('click', function (e) {
                if (e.target === dropZone || e.target.closest('.upload-trigger')) {
                    fileInput.click();
                }
            });
        }

        let saveTimer = null;
        let isRestoring = false;
        let splitScriptText = '';
        let splitScenes = [];
        let currentSceneText = '';

        function serializeState() {
            return {
                sessions: sessions.filter(s => (s.sourceImage || s.thumb)).map(s => {
                    const mergedMeta = { ...(s.meta || {}) };
                    if (s.id === activeSessionId) {
                        mergedMeta.splitScriptText = splitScriptText;
                        mergedMeta.splitScenes = splitScenes;
                        mergedMeta.currentSceneText = currentSceneText;
                    }
                    return {
                        id: s.id,
                        name: s.name,
                        thumb: s.thumb,
                        timestamp: s.timestamp instanceof Date ? s.timestamp.toISOString() : s.timestamp,
                        sourceImage: s.sourceImage || s.thumb,
                        tileOrder: s.tiles.map(t => t.id),
                        selectedIds: s.tiles.filter(t => t.selected).map(t => t.id),
                        meta: mergedMeta
                    };
                }),
                globalSelectedList: globalSelectedList.map(i => ({
                    instanceId: i.instanceId,
                    sessionId: i.sessionId,
                    tileId: i.tileId,
                    src: i.src,
                    badge: i.badge
                })),
                activeSessionId: activeSessionId
            };
        }

        function getClientId() {
            let id = localStorage.getItem('clientId');
            if (!id) {
                if (window.crypto && crypto.randomUUID) {
                    id = crypto.randomUUID();
                } else {
                    id = Date.now().toString(36) + Math.random().toString(36).slice(2);
                }
                localStorage.setItem('clientId', id);
            }
            return id;
        }

        async function saveState() {
            try {
                const clientId = getClientId();
                await fetch(`/api/state?client_id=${encodeURIComponent(clientId)}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(serializeState()),
                    cache: 'no-store'
                });
            } catch (e) {
                console.warn('Failed to save state', e);
            }
        }

        function scheduleSave() {
            if (isRestoring) return;
            if (saveTimer) clearTimeout(saveTimer);
            saveTimer = setTimeout(saveState, 400);
        }

        async function buildSessionFromData(data) {
            if (!data || (!data.sourceImage && !data.thumb)) {
                return null;
            }
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = function () {
                    const tilesData = performSlicing(img);
                    const byId = new Map(tilesData.map(t => [t.id, t]));

                    let ordered = tilesData;
                    if (Array.isArray(data.tileOrder) && data.tileOrder.length) {
                        ordered = data.tileOrder.map(id => byId.get(id)).filter(Boolean);
                    }

                    const selectedSet = new Set(Array.isArray(data.selectedIds) ? data.selectedIds : []);
                    if (selectedSet.size > 0) {
                        ordered.forEach(t => { t.selected = selectedSet.has(t.id); });
                    }

                    resolve({
                        id: data.id || Date.now(),
                        name: data.name || `åˆ‡ç‰‡ç»„ ${sessions.length + 1}`,
                        thumb: data.thumb || data.sourceImage,
                        timestamp: data.timestamp ? new Date(data.timestamp) : new Date(),
                        tiles: ordered,
                        sourceImage: data.sourceImage || data.thumb,
                        meta: data.meta || {}
                    });
                };
                img.src = data.sourceImage || data.thumb;
            });
        }

        function hydrateSelectedList(savedList) {
            const rebuilt = [];
            (savedList || []).forEach(item => {
                const session = sessions.find(s => s.id === item.sessionId);
                const tile = session ? session.tiles.find(t => t.id === item.tileId) : null;
                if (tile) {
                    rebuilt.push({
                        instanceId: item.instanceId || generateInstanceId(),
                        sessionId: item.sessionId,
                        tileId: item.tileId,
                        src: tile.src,
                        badge: tile.badge
                    });
                } else if (item.src) {
                    rebuilt.push({
                        instanceId: item.instanceId || generateInstanceId(),
                        sessionId: item.sessionId,
                        tileId: item.tileId,
                        src: item.src,
                        badge: item.badge || ''
                    });
                }
            });
            return rebuilt;
        }

        function renderSplitResults(scenes) {
            const resultArea = document.getElementById('splitResults');
            if (!resultArea) return;
            resultArea.style.display = 'flex';
            resultArea.innerHTML = '';

            scenes.forEach((scene) => {
                const title = scene?.title || 'æœªå‘½åç‰‡æ®µ';
                const content = scene?.content || '';
                if (!content) return;

                const div = document.createElement('div');
                div.style.cssText = "padding: 12px; background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; cursor: pointer; transition: all 0.2s;";
                div.onmouseover = () => { div.style.background = '#f1f5f9'; div.style.borderColor = '#cbd5e1'; };
                div.onmouseout = () => { div.style.background = '#f8fafc'; div.style.borderColor = '#e2e8f0'; };
                div.onclick = () => selectScene(content);

                div.innerHTML = `
                    <div style="font-weight: 600; color: #475569; margin-bottom: 4px;">${title}</div>
                    <div style="font-size: 0.85rem; color: #64748b; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden;">${content}</div>
                `;
                resultArea.appendChild(div);
            });

            if (resultArea.children.length === 0) {
                resultArea.innerHTML = '<div style="color:#ef4444; font-size:0.9rem;">æ²¡æœ‰è¿”å›å¯ç”¨çš„ç‰‡æ®µï¼Œè¯·è°ƒæ•´å‰§æœ¬å†…å®¹æˆ–æç¤ºè¯ã€‚</div>';
            }
        }

        async function restoreState() {
            try {
                const clientId = getClientId();
                const resp = await fetch(`/api/state?client_id=${encodeURIComponent(clientId)}`, { cache: 'no-store' });
                if (!resp.ok) return;
                const data = await resp.json();
                if (!data || !Array.isArray(data.sessions)) return;

                isRestoring = true;
                splitScriptText = '';
                splitScenes = [];
                currentSceneText = '';
                sessions = [];
                globalSelectedList = [];
                activeSessionId = data.activeSessionId || null;

                for (const s of data.sessions) {
                    const session = await buildSessionFromData(s);
                    if (session) sessions.push(session);
                }

                if (sessions.length > 0) {
                    renderSessionList();
                    const active = sessions.find(s => s.id === activeSessionId) || sessions[0];
                    if (active) {
                        activeSessionId = active.id;
                    }
                }

                globalSelectedList = hydrateSelectedList(data.globalSelectedList);
                renderSelectedList();
                const activeForSummary = sessions.find(s => s.id === activeSessionId);
                const activeMeta = activeForSummary?.meta || null;
                if (activeMeta && (activeMeta.splitScriptText || activeMeta.splitScenes || activeMeta.currentSceneText)) {
                    splitScriptText = activeMeta.splitScriptText || '';
                    splitScenes = Array.isArray(activeMeta.splitScenes) ? activeMeta.splitScenes : [];
                    currentSceneText = activeMeta.currentSceneText || '';

                    const fullScriptInput = document.getElementById('fullScriptInput');
                    if (fullScriptInput) {
                        fullScriptInput.value = splitScriptText;
                        autoResize(fullScriptInput, 80);
                    }
                    if (splitScenes.length > 0) {
                        renderSplitResults(splitScenes);
                    }
                    if (currentSceneText) {
                        const stepInput = document.getElementById('step-input');
                        if (stepInput) stepInput.classList.remove('step-hidden');
                        const scriptInput = document.getElementById('scriptInput');
                        if (scriptInput) {
                            scriptInput.value = currentSceneText;
                            autoResize(scriptInput, 100);
                        }
                    }
                }
                if (activeForSummary) updateSummary(activeForSummary);
                resetToInitialView({ clearState: false, saveState: false });
            } catch (e) {
                console.warn('Failed to restore state', e);
            } finally {
                isRestoring = false;
            }
        }

        // Initialize drag and drop when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            initRefDragAndDrop('sceneRefDropZone', 'sceneRefUpload');
            initRefDragAndDrop('scriptRefDropZone', 'scriptRefUpload');
            restoreState();
        });

        // ================= PROMPT CONFIG SYSTEM =================
        const promptConfig = {
            split: `# Role
ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„å½±è§†å‰§æœ¬ç»Ÿç­¹ï¼ˆScript Supervisorï¼‰ï¼Œæ“…é•¿åˆ†æå‰§æœ¬ç»“æ„ï¼Œå¹¶æ ¹æ®å·¥ä½œæµéœ€æ±‚å¯¹å‰§æœ¬è¿›è¡Œç§‘å­¦ã€åˆç†çš„æ®µè½æ‹†è§£ã€‚

# Task
è¯·é˜…è¯»ç”¨æˆ·æä¾›çš„å‰§æœ¬å†…å®¹ï¼Œä¸¥æ ¼æŒ‰ç…§ä¸‹è¿°[æ‹†è§£è§„åˆ™]å¯¹å‰§æœ¬è¿›è¡Œåˆ†æ®µå¤„ç†ã€‚

# Constraints (æ‹†è§£è§„åˆ™)
1.  **åœºæ™¯ä¼˜å…ˆåŸåˆ™**ï¼š
    * æ£€æµ‹åˆ°åœºæ™¯åˆ‡æ¢ï¼ˆå¦‚ï¼šå¤§åœºæ™¯å˜æ›´ã€æ—¶é—´åœ°ç‚¹å˜æ›´ã€æ˜æ˜¾çš„â€œå†…/å¤–æ™¯â€æ ‡è¯†ï¼‰æ—¶ï¼Œå¿…é¡»å¼ºåˆ¶åˆ†æ®µã€‚

2.  **é•¿åº¦é™åˆ¶åŸåˆ™**ï¼š
    * ä»¥â€œé•œå¤´â€æˆ–â€œåŠ¨ä½œ/å¯¹è¯å—â€ä¸ºè®¡æ•°å•ä½ã€‚
    * å¦‚æœå•ä¸€åœºæ™¯å†…çš„å†…å®¹è¶…è¿‡ **15ä¸ªé•œå¤´/äº¤äº’å—**ï¼Œå¿…é¡»åœ¨ä¿æŒè¯­ä¹‰è¿è´¯çš„å‰æä¸‹è¿›è¡ŒäºŒæ¬¡æ‹†åˆ†ï¼ˆä¾‹å¦‚åˆ†ä¸º Part 1, Part 2ï¼‰ã€‚

3.  **å‡è¡¡æ€§åŸåˆ™**ï¼š
    * åœ¨æ»¡è¶³ä¸Šè¿°è§„åˆ™çš„å‰æä¸‹ï¼Œå°½é‡é¿å…å‡ºç°æŸä¸€æ®µå­—æ•°æå°‘ï¼ˆå¦‚ä»…ä¸€ä¸¤è¡Œï¼‰æˆ–æå¤šï¼ˆå¤§æ®µæ–‡å­—å †ç Œï¼‰çš„æƒ…å†µã€‚
    * å¦‚æœä¸€ä¸ªåœºæ™¯æçŸ­ï¼ˆå¦‚åªæœ‰1ä¸ªé•œå¤´ï¼‰ï¼Œä¸”ç´§æ¥ç€çš„ä¸‹ä¸€ä¸ªåœºæ™¯ä¹Ÿè¾ƒçŸ­ï¼Œåœ¨ä¸å½±å“é€»è¾‘ç†è§£çš„æƒ…å†µä¸‹ï¼Œå¯ä»¥å°†è¿‡æ¸¡æ€§çŸ­åœºæ™¯å•ç‹¬åˆ—ä¸ºä¸€æ®µï¼Œä½†ä¸è¦å¼ºè¡Œåˆå¹¶åˆ°ä¸ç›¸å…³çš„åœºæ™¯ä¸­ã€‚

4.  **å†…å®¹é›¶ç¯¡æ”¹åŸåˆ™ (è‡³å…³é‡è¦)**ï¼š
    * **ä¸¥ç¦**ä¿®æ”¹ã€æ¶¦è‰²ã€å¢åŠ æˆ–åˆ é™¤å‰§æœ¬ä¸­çš„ä»»ä½•æ–‡å­—ã€æ ‡ç‚¹æˆ–æ ¼å¼ã€‚
    * ä½ çš„å·¥ä½œä»…ä»…æ˜¯â€œåˆ‡åˆ†â€ï¼Œå°±åƒç”¨å‰ªåˆ€å‰ªçº¸å¸¦ä¸€æ ·ï¼Œä¸è¦åœ¨ä¸Šé¢å†™å­—ã€‚

5.  **å³æ—¶åˆ¤æ–­æœºåˆ¶**ï¼š
    * åœ¨è¾“å‡ºå‰å…ˆè¿›è¡Œè‡ªæˆ‘é¢„æ£€ã€‚å¦‚æœä¸Šä¼ çš„å†…å®¹æœ¬èº«è¾ƒçŸ­ï¼ˆæœªå‘ç”Ÿåœºæ™¯åˆ‡æ¢ä¸”å°‘äº15ä¸ªé•œå¤´ï¼‰ï¼Œåˆ™ä¸éœ€è¦å¼ºè¡Œæ‹†åˆ†ï¼Œ**åŸæ ·è¾“å‡º**å³å¯ã€‚

# Output Format
è¯·æŒ‰ç…§ä»¥ä¸‹æ ¼å¼è¾“å‡ºæ‹†è§£åçš„å†…å®¹ï¼ˆä½¿ç”¨åˆ†å‰²çº¿åŒºåˆ†ï¼‰ï¼š

=== ç¬¬ 1 æ®µ ===
[å‰§æœ¬åŸå§‹å†…å®¹]

=== ç¬¬ 2 æ®µ ===
[å‰§æœ¬åŸå§‹å†…å®¹]

...

# Workflow
1. æ¥æ”¶ç”¨æˆ·è¾“å…¥çš„å‰§æœ¬ã€‚
2. æ‰«æåœºæ™¯å…³é”®è¯ï¼ˆå¦‚ï¼šæ—¥ã€å¤œã€å†…ã€å¤–ã€åœºæ™¯åï¼‰ã€‚
3. ç»Ÿè®¡æ¯ä¸ªè‡ªç„¶æ®µæˆ–é•œå¤´å·çš„æ•°é‡ã€‚
4. åº”ç”¨æ‹†è§£è§„åˆ™ã€‚
5. è¾“å‡ºæœ€ç»ˆç»“æœã€‚

# Input
[è¯·åœ¨æ­¤å¤„ç²˜è´´ä½ çš„å‰§æœ¬å†…å®¹]`,
            shot: `(NanoBananaProè§†è§’è£‚å˜ä¸“å®¶



  :æ ¸å¿ƒè§’è‰² "å¤šç»´è§†è§’ä¸€è‡´æ€§ç”ŸæˆåŠ©æ‰‹ (5x5)"



  :ç›®çš„ "åŸºäºç”¨æˆ·æä¾›çš„å•å¼ å‚è€ƒå›¾æè¿°ï¼Œä¿æŒè§†è§‰é”šç‚¹ç»å¯¹ä¸å˜ï¼Œé€šè¿‡ç‰¹å®šè§†è§’çš„å¼ºåŒ–ç»„åˆï¼Œç”Ÿæˆ25ä¸ªï¼ˆ5x5å®«æ ¼ï¼‰æå…·æ²‰æµ¸æ„Ÿçš„JSONæ ¼å¼ä¸­æ–‡æç¤ºè¯ã€‚"



  :é€‚é…æ¨¡å‹ "NanoBananaPro"



  ;;â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  ;; æ ¸å¿ƒèƒ½åŠ›è®¾å®š

  ;;â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  :èƒ½åŠ› (

    (è§†è§‰é”å®š "èƒ½å¤Ÿç²¾å‡†æå–å¹¶é”å®šå‚è€ƒå›¾ä¸­çš„æ ¸å¿ƒå…ƒç´ ï¼ˆäººç‰©IDã€è¡£ç€ç»†èŠ‚ã€ç¯å¢ƒå¸ƒå±€ã€ç‰¹å®šå…‰å½±ï¼‰ï¼Œç¡®ä¿åœ¨25å¼ åˆ†é•œä¸­è¿™äº›æè¿°ä¸€å­—ä¸å·®æˆ–é«˜åº¦ä¸€è‡´ã€‚")

    (ç‰¹å®šé•œå¤´å¼ºåŒ– "ä¾§é‡äºæ²‰æµ¸å¼å’Œå…³ç³»è§†è§’çš„æ„å»ºï¼Œé‡ç‚¹ç”ŸæˆèƒŒåã€è¿‡è‚©åŠä¸»è§‚é•œå¤´ã€‚")

    (éšæœºæ’åˆ— "èƒ½å¤Ÿç”Ÿæˆ9ç§é«˜å¼ åŠ›çš„é•œå¤´ç»„åˆï¼Œé¿å…å¹³åº¸çš„å¹³è§†é•œå¤´ã€‚")

    (æ ¼å¼è¾“å‡º "ä¸¥æ ¼éµå®ˆNanoBananaProçš„JSONæ ¼å¼è¦æ±‚ï¼Œè¾“å‡º5x5å¸ƒå±€é…ç½®ã€‚")

  )



  ;;â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  ;; å˜é‡åº“ (å·²æ ¹æ®è¦æ±‚è°ƒæ•´)

  ;;â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  :é•œå¤´å˜é‡åº“ (

    ;; å‰”é™¤äº†å¸¸è§„çš„ Long, Medium, Closeï¼Œä¿ç•™æç«¯çš„æˆ–æ›´æœ‰å¼ åŠ›çš„æ™¯åˆ«

    (æ™¯åˆ« '( "Extreme Close-up (ECU - Focus on eyes/details)" "Full Body Shot" "Cowboy Shot (Thigh-up)" "Upper Body Shot (Chest-up)" "Wide Angle Full Shot" ))

    

    ;; å¼ºè°ƒäº†éœ€è¦çš„è§†è§’ï¼Œä½†ä¿ç•™éƒ¨åˆ†å…¶ä»–è§†è§’ä»¥ä¾›å¡«å……å‰©ä½™ç©ºä½

    (è§†è§’ '( "Back View (Walking away/Looking at scenery)" "Over-the-Shoulder (OTS)" "Point of View (POV)" "Low Angle (Heroic)" "High Angle (Vulnerable)" "Dutch Angle (Tilted)" "Top-Down / God's Eye View" ))

    

    (æ„å›¾ '( "Rule of Thirds" "Center Composition" "Depth of Field (Bokeh)" "Framing within a frame" "Dynamic Diagonal" ))

  )
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  ;; çº¦æŸæ¨¡å— (ç¡¬æ€§è§„å®š)

  ;;â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  :çº¦æŸ (

    (C1 "ä¸€è‡´æ€§ç»å¯¹ä¼˜å…ˆï¼šæ— è®ºè§†è§’å¦‚ä½•å˜åŒ–ï¼Œäººç‰©ç‰¹å¾ï¼ˆå‘å‹ã€è¡£ç€ã€é¢å­”ï¼‰å’Œç¯å¢ƒå¿…é¡»ä¿æŒä¸€è‡´ã€‚")

    (C2 "è§†è§’å¼ºåˆ¶åˆ†å¸ƒï¼š25ä¸ªåˆ†é•œä¸­å¿…é¡»åŒ…å«ï¼š

         - è‡³å°‘ 6ä¸ª èƒŒåè§†è§’ (Back View)ï¼›

         - è‡³å°‘ 8ä¸ª è¿‡è‚©è§†è§’ (Over-the-Shoulder)ï¼›

         - è‡³å°‘ 6ä¸ª ä¸»è§‚è§†è§’ (Point of View/POV)ï¼›

         - å‰©ä½™ 5ä¸ª è‡ªç”±é€‰æ‹©é«˜å¼ åŠ›è§†è§’ï¼ˆå¦‚ä¸Šå¸è§†è§’æˆ–å¤§ç‰¹å†™ï¼‰ã€‚")

    (C3 "æ™¯åˆ«é™åˆ¶ï¼šä¸¥ç¦ä½¿ç”¨ 'Medium Shot', 'Long Shot', 'Close-up' è¿™ç§å¹³åº¸çš„æè¿°ã€‚è¯·ä½¿ç”¨ 'Cowboy Shot', 'Extreme Close-up', 'Full Body' ç­‰æ›¿ä»£ã€‚")

    (C4 "æ ¼å¼è§„èŒƒï¼šJSONå¿…é¡»çº¯å‡€ï¼Œshotsæ•°ç»„å¿…é¡»ç²¾ç¡®åŒ…å«25ä¸ªå¯¹è±¡ã€‚")

    (C5 "æ–‡å­—æŒ‡ä»¤ï¼šæ¯ä¸ªpromptå¿…é¡»åŒ…å« \"'åˆ†é•œX' in the top-left corner\" å’Œ \"no timecode, no subtitles\"ã€‚")

    (C6 "è¯­è¨€ï¼šPromptå†…å®¹å¿…é¡»ä¸ºä¸­æ–‡ã€‚")

  )



  ;;â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  ;; è¿è¡ŒæŒ‡ä»¤

  ;;â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  (è¿è¡Œæ–¹æ³• "è¯·ç”¨æˆ·è¾“å…¥å‚è€ƒå›¾çš„è¯¦ç»†æè¿°ï¼ˆä¸­æ–‡ï¼‰ï¼ŒåŠ©æ‰‹å°†è‡ªåŠ¨ç”ŸæˆåŒ…å«25ä¸ªï¼ˆ5x5ï¼‰ç‰¹å®šå¼ºåŒ–è§†è§’çš„JSONä»£ç å—ã€‚")

)`
        };
        const promptDefaults = { ...promptConfig };

        let currentEditingPromptType = null;

        function openPromptModal(type) {
            currentEditingPromptType = type;
            const modal = document.getElementById('promptModal');
            const textarea = document.getElementById('promptConfigInput');

            textarea.value = promptConfig[type];
            modal.classList.add('active');
        }

        function closeModal() {
            document.getElementById('promptModal').classList.remove('active');
            currentEditingPromptType = null;
        }

        function savePrompt() {
            if (!currentEditingPromptType) return;

            const textarea = document.getElementById('promptConfigInput');
            promptConfig[currentEditingPromptType] = textarea.value;

            console.log(`Updated ${currentEditingPromptType} prompt:`, promptConfig[currentEditingPromptType]);
            closeModal();
        }

        function autoResize(textarea, minPx) {
            if (!textarea) return;
            if (!textarea.value) {
                textarea.style.height = `${minPx}px`;
                return;
            }
            textarea.style.height = 'auto';
            textarea.style.height = textarea.scrollHeight + 'px';
        }

        /* ================= é€»è¾‘ä»£ç  ================= */

        // 0. Step 1: Script Splitting Logic
        async function splitScript() {
            const input = document.getElementById('fullScriptInput').value;
            const btn = document.querySelector('#card-split button.primary');
            const resultArea = document.getElementById('splitResults');

            if (!input || input.length < 5) {
                // Allow short input for demo purposes, but warn if empty
                if (!input) {
                    alert("è¯·å…ˆè¾“å…¥å‰§æœ¬å†…å®¹");
                    return;
                }
            }

            const originalText = btn.innerHTML;
            btn.disabled = true;
            btn.innerHTML = 'ğŸ¤– åˆ†æä¸­...';

            try {
                const resp = await fetch('/api/split', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        script: input,
                        system_prompt: promptConfig.split
                    })
                });

                if (!resp.ok) {
                    const detail = await resp.text();
                    throw new Error(detail || `HTTP ${resp.status}`);
                }

                const data = await resp.json();
                const scenes = Array.isArray(data.scenes) ? data.scenes : [];

                splitScriptText = input;
                splitScenes = scenes;
                renderSplitResults(scenes);
                scheduleSave();
            } catch (err) {
                console.error(err);
                alert("æ‹†åˆ†å¤±è´¥");
            } finally {
                btn.disabled = false;
                btn.innerHTML = originalText;
            }
        }

        function selectScene(content) {
            const scriptInput = document.getElementById('scriptInput');
            scriptInput.value = content;
            autoResize(scriptInput, 100);
            currentSceneText = content;
            scheduleSave();

            // Show Step 2 (Scene Description)
            const stepInput = document.getElementById('step-input');
            stepInput.classList.remove('step-hidden');
            stepInput.scrollIntoView({ behavior: 'smooth', block: 'start' });

            // Highlight effect
            scriptInput.style.transition = 'background 0.3s';
            scriptInput.style.background = '#e0e7ff';
            setTimeout(() => scriptInput.style.background = '#f1f5f9', 500);
        }

        function renderScriptReviewFromSession(session) {
            const meta = session?.meta || {};
            const shotTexts = Array.isArray(meta.shotTexts) ? meta.shotTexts : [];
            const sceneText = typeof meta.sceneText === 'string' ? meta.sceneText : '';
            const savedPromptConfig = meta.promptConfig || null;
            const savedSplitScriptText = typeof meta.splitScriptText === 'string' ? meta.splitScriptText : '';
            const savedSplitScenes = Array.isArray(meta.splitScenes) ? meta.splitScenes : [];
            const savedCurrentSceneText = typeof meta.currentSceneText === 'string' ? meta.currentSceneText : '';

            if (savedPromptConfig) {
                if (typeof savedPromptConfig.split === 'string') promptConfig.split = savedPromptConfig.split;
                if (typeof savedPromptConfig.shot === 'string') promptConfig.shot = savedPromptConfig.shot;
            }

            if (savedSplitScriptText || savedSplitScenes.length || savedCurrentSceneText) {
                splitScriptText = savedSplitScriptText;
                splitScenes = savedSplitScenes;
                currentSceneText = savedCurrentSceneText;

                const fullScriptInput = document.getElementById('fullScriptInput');
                if (fullScriptInput) {
                    fullScriptInput.value = splitScriptText;
                    autoResize(fullScriptInput, 80);
                }
                if (splitScenes.length > 0) {
                    renderSplitResults(splitScenes);
                }
            } else {
                splitScriptText = '';
                splitScenes = [];
                currentSceneText = '';
                const fullScriptInput = document.getElementById('fullScriptInput');
                if (fullScriptInput) {
                    fullScriptInput.value = '';
                    autoResize(fullScriptInput, 80);
                }
                const splitResults = document.getElementById('splitResults');
                if (splitResults) {
                    splitResults.style.display = 'none';
                    splitResults.innerHTML = '';
                }
                const stepInput = document.getElementById('step-input');
                if (stepInput) stepInput.classList.add('step-hidden');
                const stepReview = document.getElementById('step-script-review');
                if (stepReview) stepReview.classList.add('step-hidden');
                const scriptInput = document.getElementById('scriptInput');
                if (scriptInput) {
                    scriptInput.value = '';
                    autoResize(scriptInput, 100);
                }
                const container = document.getElementById('scriptListContainer');
                if (container) {
                    container.innerHTML = '<div style="text-align: center; color: var(--text-sub); padding: 20px;">ç­‰å¾…ç”Ÿæˆ...</div>';
                }
                const sceneRefContainer = document.getElementById('sceneRefImages');
                const scriptRefContainer = document.getElementById('scriptRefImages');
                const sceneRefPlaceholder = document.getElementById('sceneRefPlaceholder');
                const scriptRefPlaceholder = document.getElementById('scriptRefPlaceholder');
                if (sceneRefContainer) sceneRefContainer.innerHTML = '';
                if (scriptRefContainer) scriptRefContainer.innerHTML = '';
                if (sceneRefPlaceholder) sceneRefPlaceholder.classList.remove('has-items');
                if (scriptRefPlaceholder) scriptRefPlaceholder.classList.remove('has-items');
            }

            const scriptInput = document.getElementById('scriptInput');
            if (scriptInput) {
                scriptInput.value = sceneText || currentSceneText || '';
            }

            const stepInput = document.getElementById('step-input');
            if (stepInput) {
                if (sceneText || currentSceneText) {
                    stepInput.classList.remove('step-hidden');
                } else {
                    stepInput.classList.add('step-hidden');
                }
            }
            if (scriptInput && (sceneText || currentSceneText)) {
                requestAnimationFrame(() => autoResize(scriptInput, 100));
            }

            const stepReview = document.getElementById('step-script-review');
            if (stepReview) {
                if (shotTexts.length > 0) {
                    stepReview.classList.remove('step-hidden');
                } else {
                    stepReview.classList.add('step-hidden');
                }
            }

            const container = document.getElementById('scriptListContainer');
            if (!container) return;
            container.innerHTML = '';

            if (shotTexts.length === 0) {
                container.innerHTML = '<div style="color:#94a3b8; font-size:0.9rem;">æš‚æ— åˆ†é•œå†…å®¹</div>';
            } else {
                shotTexts.forEach((content, idx) => {
                    if (!content) return;
                    const item = document.createElement('div');
                    item.className = 'script-item';
                    item.innerHTML = `
                        <div class="shot-badge">Shot ${idx + 1}</div>
                        <div class="script-content">
                            <textarea class="script-textarea" oninput="autoResize(this, 60)">${content}</textarea>
                        </div>
                    `;
                    container.appendChild(item);

                    const ta = item.querySelector('textarea');
                    setTimeout(() => {
                        autoResize(ta, 60);
                    }, 0);
                });
            }
            const sceneRefContainer = document.getElementById('sceneRefImages');
            const scriptRefContainer = document.getElementById('scriptRefImages');
            const sceneRefPlaceholder = document.getElementById('sceneRefPlaceholder');
            const scriptRefPlaceholder = document.getElementById('scriptRefPlaceholder');
            if (sceneRefContainer) sceneRefContainer.innerHTML = '';
            if (scriptRefContainer) scriptRefContainer.innerHTML = '';
            if (sceneRefPlaceholder) sceneRefPlaceholder.classList.remove('has-items');
            if (scriptRefPlaceholder) scriptRefPlaceholder.classList.remove('has-items');
        }

        // 1. Generate Script / Prompts
        async function generatePrompts() {
            const input = document.getElementById('scriptInput').value || "é»˜è®¤å‰§æœ¬";
            const btn = document.querySelector('#card-input button.primary');
            const originalText = btn.innerText;

            btn.innerText = "âœ¨ ç”Ÿæˆä¸­...";
            btn.disabled = true;

            try {
                let refImages = collectRefImages('sceneRefImages');
                if (refImages.length > 0) {
                    const compressed = await Promise.all(refImages.map(async (img) => {
                        const dataUrl = `data:${img.mime_type};base64,${img.data}`;
                        const approxBytes = Math.floor((img.data.length * 3) / 4);
                        if (approxBytes <= SHOTS_REF_TARGET_BYTES) return img;
                        const compressedUrl = await compressImageDataUrl(dataUrl, {
                            maxEdge: SHOTS_REF_MAX_EDGE,
                            targetBytes: SHOTS_REF_TARGET_BYTES,
                            startQuality: SHOTS_REF_START_QUALITY,
                            minQuality: SHOTS_REF_MIN_QUALITY
                        });
                        return dataUrlToRef(compressedUrl) || img;
                    }));
                    refImages = compressed.filter(Boolean);
                }
                const resp = await fetch('/api/shots', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        scene: input,
                        system_prompt: promptConfig.shot,
                        count: 25,
                        ref_images: refImages
                    })
                });

                if (!resp.ok) {
                    const detail = await resp.text();
                    throw new Error(detail || `HTTP ${resp.status}`);
                }

                const data = await resp.json();
                const shots = Array.isArray(data.shots) ? data.shots : [];

                // Show Step 3 (Script Review)
                const stepReview = document.getElementById('step-script-review');
                stepReview.classList.remove('step-hidden');
                stepReview.scrollIntoView({ behavior: 'smooth', block: 'start' });

                // Transfer Reference Images
                const sceneRefContainer = document.getElementById('sceneRefImages');
                const scriptRefContainer = document.getElementById('scriptRefImages');
                scriptRefContainer.innerHTML = ''; // Clear previous

                if (sceneRefContainer.children.length > 0) {
                    Array.from(sceneRefContainer.children).forEach(child => {
                        const clone = child.cloneNode(true);
                        scriptRefContainer.appendChild(clone);
                    });
                }

                // Render Shots
                const container = document.getElementById('scriptListContainer');
                container.innerHTML = '';

                shots.forEach((shot, idx) => {
                    const shotNum = shot?.shotNum || (idx + 1);
                    const content = shot?.content || '';
                    if (!content) return;

                    const item = document.createElement('div');
                    item.className = 'script-item';
                    item.innerHTML = `
                        <div class="shot-badge">Shot ${shotNum}</div>
                        <div class="script-content">
                            <textarea class="script-textarea" oninput="this.style.height='auto';this.style.height=this.scrollHeight+'px'">${content}</textarea>
                        </div>
                    `;
                    container.appendChild(item);

                    const ta = item.querySelector('textarea');
                    setTimeout(() => {
                        autoResize(ta, 60);
                    }, 0);
                });

                if (container.children.length === 0) {
                    container.innerHTML = '<div style="color:#ef4444; font-size:0.9rem;">æ²¡æœ‰è¿”å›å¯ç”¨çš„åˆ†é•œï¼Œè¯·è°ƒæ•´åœºæ™¯æè¿°æˆ–æç¤ºè¯ã€‚</div>';
                }
            } catch (err) {
                console.error(err);
                alert("ç”Ÿæˆåˆ†é•œå¤±è´¥");
            } finally {
                btn.innerText = originalText;
                btn.disabled = false;
            }
        }

        // 2. Generate Images
        function collectRefImages(containerId) {
            const container = document.getElementById(containerId);
            if (!container) return [];
            const imgs = container.querySelectorAll('img');
            const results = [];
            imgs.forEach(img => {
                const src = img.getAttribute('src') || '';
                if (!src.startsWith('data:')) return;
                const match = src.match(/^data:([^;]+);base64,(.+)$/);
                if (!match) return;
                results.push({ mime_type: match[1], data: match[2] });
            });
            return results;
        }

        async function generateAndLoadImages() {
            const btn = document.querySelector('#card-script-review button.primary');

            // Gather script from list
            const textareas = document.querySelectorAll('#scriptListContainer .script-textarea');
            const lines = Array.from(textareas).map((ta, i) => `[Shot ${i + 1}] ${ta.value}`);
            const promptVal = lines.join('\n\n');
            const shotTexts = Array.from(textareas).map((ta) => ta.value);
            const sceneText = document.getElementById('scriptInput')?.value || '';

            if (!promptVal || lines.length === 0) {
                alert("è¯·å…ˆç¡®è®¤è„šæœ¬å†…å®¹");
                return;
            }

            const originalText = btn.innerText;
            btn.innerText = "ğŸ¨ ç»˜ç”»ä¸­...";
            btn.disabled = true;

            try {
                const refImages = collectRefImages('scriptRefImages');
                console.log("refImages count:", refImages.length);
                refImages.forEach((img, i) => {
                    const approxBytes = Math.floor((img.data.length * 3) / 4);
                    console.log(`refImages[${i}] mime=${img.mime_type} bytesâ‰ˆ${approxBytes}`);
                });
                const resp = await fetch('/api/image', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt: promptVal,
                        aspect_ratio: "16:9",
                        image_size: "1K",
                        ref_images: refImages
                    })
                });

                if (!resp.ok) {
                    const detail = await resp.text();
                    throw new Error(detail || `HTTP ${resp.status}`);
                }

                const data = await resp.json();
                if (!data?.image) {
                    throw new Error("æœªè¿”å›å›¾åƒæ•°æ®");
                }

                // Show Step 4 (Workspace)
                const stepWorkspace = document.getElementById('step-workspace');
                stepWorkspace.classList.remove('step-hidden');
                stepWorkspace.scrollIntoView({ behavior: 'smooth', block: 'start' });

                loadImageAndCreateSession(data.image, {
                    source: 'ai',
                    createdAt: new Date().toISOString(),
                    prompt: promptVal,
                    sceneText,
                    shotTexts,
                    splitScriptText,
                    splitScenes,
                    currentSceneText,
                    promptConfig: { split: promptConfig.split, shot: promptConfig.shot },
                    refImageCount: refImages.length
                });
            } catch (err) {
                console.error(err);
                alert("ç”Ÿæˆå›¾åƒå¤±è´¥");
            } finally {
                btn.innerText = originalText;
                btn.disabled = false;
            }
        }

        // ================= SESSION MANAGEMENT SYSTEM =================
        let sessions = [];
        let activeSessionId = null;
        let globalSelectedList = []; // Array of { instanceId, sessionId, tileId, src, badge }

        let selectedListSortable = null;
        let gridSortable = null;

        function generateInstanceId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2);
        }

        function updateSummary(session) {
            const summaryElement = document.getElementById('summaryText');
            if (!summaryElement) return;
            summaryElement.textContent = "å½“å‰å·²é€‰æ‹© " + globalSelectedList.length + " ä¸ªåˆ‡ç‰‡ã€‚å¯ä»¥ä»å³ä¾§é‡å¤æ‹–æ‹½æˆ–ç‚¹å‡»æ·»åŠ ï¼Œæ‹–æ‹½æ’åºï¼Œå¹¶ä½¿ç”¨ä¸‹æ–¹æŒ‰é’®å¯¼å‡ºå›¾ç‰‡åºåˆ—ã€‚";
        }

        function handleImageUpload(input) {
            if (input.files && input.files[0]) {
                const reader = new FileReader();
                reader.onload = function (e) {
                    loadImageAndCreateSession(e.target.result, {
                        source: 'upload',
                        createdAt: new Date().toISOString()
                    });
                }
                reader.readAsDataURL(input.files[0]);
                input.value = '';
            }
        }

        const REF_MAX_EDGE = 3840;
        const REF_TARGET_BYTES = 500 * 1024;
        const REF_START_QUALITY = 0.92;
        const REF_MIN_QUALITY = 0.75;
        const REF_SKIP_UNDER_BYTES = 5 * 1024 * 1024;

        // Smaller target for text+image (shots) requests
        const SHOTS_REF_MAX_EDGE = 1536;
        const SHOTS_REF_TARGET_BYTES = 200 * 1024;
        const SHOTS_REF_START_QUALITY = 0.85;
        const SHOTS_REF_MIN_QUALITY = 0.6;

        function estimateBase64Bytes(dataUrl) {
            const idx = dataUrl.indexOf(',');
            if (idx === -1) return 0;
            const b64 = dataUrl.slice(idx + 1);
            return Math.floor((b64.length * 3) / 4);
        }

        function fileToDataUrl(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        function dataUrlToRef(dataUrl) {
            const match = dataUrl.match(/^data:([^;]+);base64,(.+)$/);
            if (!match) return null;
            return { mime_type: match[1], data: match[2] };
        }

        function compressImageDataUrl(dataUrl, { maxEdge, targetBytes, startQuality, minQuality }) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    let { width, height } = img;
                    const longest = Math.max(width, height);
                    const scale = longest > maxEdge ? maxEdge / longest : 1;
                    width = Math.round(width * scale);
                    height = Math.round(height * scale);

                    const canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    if (!ctx) {
                        reject(new Error('Canvas not supported'));
                        return;
                    }
                    ctx.drawImage(img, 0, 0, width, height);

                    let quality = startQuality;
                    let out = canvas.toDataURL('image/jpeg', quality);
                    while (estimateBase64Bytes(out) > targetBytes && quality > minQuality) {
                        quality = Math.max(minQuality, quality - 0.07);
                        out = canvas.toDataURL('image/jpeg', quality);
                        if (quality === minQuality) break;
                    }
                    resolve(out);
                };
                img.onerror = reject;
                img.src = dataUrl;
            });
        }

        function appendRefImage(container, dataUrl, placeholderId) {
            const div = document.createElement('div');
            div.className = 'ref-image-item';
            div.innerHTML = `
                <img src="${dataUrl}">
                <div class="ref-image-delete" onclick="event.stopPropagation(); removeRefImage(this, '${placeholderId}')">Ã—</div>
            `;

            const addBtn = container.querySelector('.ref-add-more');
            if (addBtn) {
                container.insertBefore(div, addBtn);
            } else {
                container.appendChild(div);
                const newAddBtn = document.createElement('div');
                newAddBtn.className = 'ref-add-more';
                newAddBtn.innerHTML = '+';
                container.appendChild(newAddBtn);
            }
        }

        async function handleRefUpload(input, containerId) {
            if (!input.files || input.files.length === 0) return;

            const container = document.getElementById(containerId);
            const placeholderId = containerId.replace('Images', 'Placeholder');
            const placeholder = document.getElementById(placeholderId);

            if (placeholder) placeholder.classList.add('has-items');

            for (const file of Array.from(input.files)) {
                try {
                    const raw = await fileToDataUrl(file);
                    if (file.size < REF_SKIP_UNDER_BYTES) {
                        appendRefImage(container, raw, placeholderId);
                    } else {
                        const compressed = await compressImageDataUrl(raw, {
                            maxEdge: REF_MAX_EDGE,
                            targetBytes: REF_TARGET_BYTES,
                            startQuality: REF_START_QUALITY,
                            minQuality: REF_MIN_QUALITY
                        });
                        appendRefImage(container, compressed, placeholderId);
                    }
                } catch (e) {
                    console.error(e);
                }
            }

            input.value = '';
        }

        function removeRefImage(btn, placeholderId) {
            const item = btn.parentElement;
            const container = item.parentElement;
            item.remove();

            // Check if any images remain
            const hasImages = container.querySelectorAll('.ref-image-item').length > 0;

            if (!hasImages) {
                const placeholder = document.getElementById(placeholderId);
                if (placeholder) placeholder.classList.remove('has-items');

                // Remove add button
                const addBtn = container.querySelector('.ref-add-more');
                if (addBtn) addBtn.remove();
            }
        }

        function loadImageAndCreateSession(src, meta = {}) {
            const img = new Image();
            img.onload = function () {
                const tilesData = performSlicing(img);

                const newSession = {
                    id: Date.now(),
                    name: `åˆ‡ç‰‡ç»„ ${sessions.length + 1}`,
                    thumb: src,
                    timestamp: new Date(),
                    tiles: tilesData,
                    sourceImage: src,
                    meta: meta
                    // selectedList: []
                };

                // newSession.selectedList = []; // Start empty until confirmed

                sessions.unshift(newSession);
                activeSessionId = newSession.id;

                renderSessionList();
                loadSessionToWorkspace(newSession);

                // Show Grid View
                document.getElementById('uploadArea').style.display = 'none';
                document.getElementById('gridContainer').style.display = 'flex';
                document.getElementById('workspaceActions').style.display = 'flex';

                // Ensure selected list sortable is initialized even if empty
                renderSelectedList();
                scheduleSave();
            }
            img.src = src;
        }

        function performSlicing(img) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const rows = 5;
            const cols = 5;

            const imgW = img.naturalWidth;
            const imgH = img.naturalHeight;
            const cellW = imgW / cols;
            const cellH = imgH / rows;

            canvas.width = cellW;
            canvas.height = cellH;

            const tiles = [];

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    ctx.clearRect(0, 0, cellW, cellH);
                    ctx.drawImage(img, c * cellW, r * cellH, cellW, cellH, 0, 0, cellW, cellH);

                    const dataUrl = canvas.toDataURL('image/jpeg', 0.95);
                    const index = r * cols + c;

                    tiles.push({
                        id: index,
                        src: dataUrl,
                        selected: true, // Default to selected
                        badge: `#${index + 1}`
                    });
                }
            }
            return tiles;
        }

        function renderSessionList() {
            const container = document.getElementById('sessionList');
            if (sessions.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #94a3b8; padding: 20px; font-size: 0.85rem;">æš‚æ— åˆ‡ç‰‡<br>ä¸Šä¼ å›¾ç‰‡å¼€å§‹</div>';
                return;
            }

            container.innerHTML = '';

            sessions.forEach(session => {
                const div = document.createElement('div');
                div.className = `session-item ${session.id === activeSessionId ? 'active' : ''}`;
                div.onclick = () => switchSession(session.id);

                const selectedCount = 0;

                div.innerHTML = `
                    <img class="session-thumb" src="${session.thumb}">
                    <div class="session-info">
                        <div>
                            <div style="font-weight:600;">${session.name}</div>
                            <div class="session-meta">${session.timestamp.toLocaleTimeString()}</div>
                        </div>
                        <div class="badge" style="font-size:0.7rem; display:none;">${selectedCount}é€‰</div>
                    </div>
                `;
                container.appendChild(div);
            });
        }

        function switchSession(id) {
            activeSessionId = id;
            const session = sessions.find(s => s.id === id);
            if (session) {
                renderScriptReviewFromSession(session);
                loadSessionToWorkspace(session);
                renderSessionList();
                scheduleSave();

                // Ensure grid is showing
                const stepWorkspace = document.getElementById('step-workspace');
                if (stepWorkspace) {
                    stepWorkspace.classList.remove('step-hidden');
                    stepWorkspace.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
                document.getElementById('uploadArea').style.display = 'none';
                document.getElementById('gridContainer').style.display = 'flex';
                document.getElementById('workspaceActions').style.display = 'flex';
            }
        }

        function loadSessionToWorkspace(session) {
            const grid = document.getElementById('interactiveGrid');
            grid.innerHTML = '';

            // Re-render based on current order in session.tiles (if reordered previously)
            // But wait, session.tiles is the source of truth for the grid. 
            // If we allow reordering, we must update session.tiles when drag ends.

            session.tiles.forEach(tileData => {
                const div = document.createElement('div');
                div.className = `grid-tile ${tileData.selected ? 'is-selected' : 'is-ignored'}`;
                div.setAttribute('data-id', tileData.id);

                div.innerHTML = `
                    <img src="${tileData.src}">
                    <div class="tile-badge">${tileData.badge}</div>
                `;

                div.addEventListener('click', function () {
                    tileData.selected = !tileData.selected;

                    if (tileData.selected) {
                        this.classList.remove('is-ignored');
                        this.classList.add('is-selected');
                    } else {
                        this.classList.remove('is-selected');
                        this.classList.add('is-ignored');
                    }
                    scheduleSave();
                });

                grid.appendChild(div);
            });

            initGridSortable();
        }

        // addToSelectedList removed

        function initGridSortable() {
            const el = document.getElementById('interactiveGrid');
            if (gridSortable) gridSortable.destroy();

            gridSortable = new Sortable(el, {
                group: {
                    name: 'shared',
                    pull: 'clone',
                    put: false
                },
                animation: 200,
                ghostClass: 'sortable-ghost',
                forceFallback: true,
                fallbackClass: 'sortable-drag',
                fallbackOnBody: true,
                swapThreshold: 0.65,
                delay: 0,
                onStart: function (evt) {
                    document.getElementById('selectedList').classList.add('highlight-drop-zone');
                },
                onEnd: function (evt) {
                    document.getElementById('selectedList').classList.remove('highlight-drop-zone');

                    // Update session.tiles order based on DOM
                    if (!activeSessionId) return;
                    if (evt.to !== el) return; // Only handle internal sorting

                    const session = sessions.find(s => s.id === activeSessionId);
                    if (session) {
                        const newOrderIds = Array.from(el.children).map(child => parseInt(child.getAttribute('data-id')));

                        // Create a new array sorted by the DOM order
                        const newTiles = [];
                        newOrderIds.forEach(id => {
                            const tile = session.tiles.find(t => t.id === id);
                            if (tile) newTiles.push(tile);
                        });
                        session.tiles = newTiles;
                    }
                    scheduleSave();
                }
            });
        }

        function confirmSelection() {
            if (!activeSessionId) return;
            const session = sessions.find(s => s.id === activeSessionId);
            if (!session) return;

            // Identify currently selected tiles in the grid
            const currentSelectedTiles = session.tiles.filter(t => t.selected);

            if (currentSelectedTiles.length === 0) {
                // Optional: Alert user or just do nothing
                return;
            }

            // Add selected items to global list (append)
            currentSelectedTiles.forEach(tile => {
                globalSelectedList.push({
                    instanceId: generateInstanceId(),
                    sessionId: session.id,
                    tileId: tile.id,
                    src: tile.src,
                    badge: tile.badge
                });
            });

            renderSelectedList();
            updateSummary(session);
            scheduleSave();

            const btn = document.querySelector('#workspaceActions button.primary');
            if (btn) {
                const originalText = btn.innerText;
                btn.innerText = "ğŸ‘Œ å·²æ·»åŠ ";
                setTimeout(() => btn.innerText = originalText, 1000);
            }

            // Show Step 5 (Results)
            const stepResults = document.getElementById('step-results');
            if (stepResults && stepResults.classList.contains('step-hidden')) {
                stepResults.classList.remove('step-hidden');
                stepResults.scrollIntoView({ behavior: 'smooth', block: 'end' });
            }
        }

        // syncSelectionWithSession removed

        function renderSelectedList() {
            const listEl = document.getElementById('selectedList');
            const countBadge = document.getElementById('leftCountBadge');

            countBadge.innerText = globalSelectedList.length;

            if (globalSelectedList.length === 0) {
                // Added pointer-events: none to ensure the placeholder doesn't block drag-and-drop
                listEl.innerHTML = '<div style="text-align: center; color: #94a3b8; padding: 20px; font-size: 0.85rem; pointer-events: none;">æš‚æ— å·²é€‰<br>ä»å³ä¾§ç‚¹é€‰æ·»åŠ <br><br>å¯æ‹–æ‹½æ’åº</div>';
            } else {
                // Only clear if we are doing a full re-render (which we avoid on delete now)
                listEl.innerHTML = '';

                globalSelectedList.forEach((item, index) => {
                    const div = document.createElement('div');
                    div.className = 'selected-item';
                    div.setAttribute('data-id', item.tileId);
                    div.setAttribute('data-instance-id', item.instanceId);
                    div.setAttribute('data-key', item.sessionId + '-' + item.tileId);

                    div.innerHTML = `
                        <div class="delete-btn" onclick="removeFromSelection('${item.instanceId}')">Ã—</div>
                        <div class="selected-item-frame">
                            <img src="${item.src}">
                        </div>
                        <div class="tile-badge" style="position:absolute; bottom:4px; left:4px;">#${index + 1}</div>
                    `;
                    listEl.appendChild(div);
                });
            }

            initSelectedSortable();
        }

        function removeFromSelection(instanceId) {
            // 1. Update Data
            const itemIndex = globalSelectedList.findIndex(i => i.instanceId === instanceId);
            if (itemIndex === -1) return;
            const item = globalSelectedList[itemIndex];
            globalSelectedList.splice(itemIndex, 1);

            // 2. Update UI (DOM) - Direct removal for stability
            const listEl = document.getElementById('selectedList');
            const itemEl = listEl.querySelector(`[data-instance-id="${instanceId}"]`);
            if (itemEl) {
                itemEl.remove();
            }

            // 3. Update Badge
            document.getElementById('leftCountBadge').innerText = globalSelectedList.length;

            // 4. Handle Empty State
            if (globalSelectedList.length === 0) {
                renderSelectedList(); // Re-render to show placeholder
            }

            // 5. Update Session Summary
            const session = sessions.find(s => s.id === item.sessionId);
            if (session) {
                updateSummary(session);
            }

            // 6. Update Badges (Sequential Numbering)
            const badges = listEl.querySelectorAll('.selected-item .tile-badge');
            badges.forEach((badge, index) => {
                badge.innerText = `#${index + 1}`;
            });
            scheduleSave();
        }

        function clearSelectedList() {
            if (!confirm("ç¡®å®šæ¸…ç©ºå·²é€‰åˆ†é•œå—ï¼Ÿ")) return;
            globalSelectedList = [];
            renderSelectedList();
            const session = sessions.find(s => s.id === activeSessionId);
            if (session) updateSummary(session);
            scheduleSave();
        }

        function initSelectedSortable() {
            if (typeof Sortable === 'undefined') {
                console.warn('SortableJS failed to load');
                return;
            }
            const el = document.getElementById('selectedList');
            if (selectedListSortable) selectedListSortable.destroy();

            selectedListSortable = new Sortable(el, {
                group: {
                    name: 'shared',
                    pull: false,
                    put: true
                },
                animation: 150,
                ghostClass: 'sortable-ghost',
                forceFallback: true,
                fallbackClass: 'sortable-drag',
                fallbackOnBody: true,
                dataIdAttr: 'data-instance-id', // Use instance ID for sorting
                onAdd: function (evt) {
                    const itemEl = evt.item;
                    const newIndex = evt.newIndex;
                    const tileId = parseInt(itemEl.getAttribute('data-id'));

                    if (isNaN(tileId) || !activeSessionId) {
                        itemEl.remove();
                        return;
                    }

                    const session = sessions.find(s => s.id === activeSessionId);
                    if (!session) {
                        itemEl.remove();
                        return;
                    }

                    const tile = session.tiles.find(t => t.id === tileId);
                    if (!tile) {
                        itemEl.remove();
                        return;
                    }

                    // Remove the dropped clone immediately
                    itemEl.remove();

                    // Always add as new item (allow duplicates)
                    const newItem = {
                        instanceId: generateInstanceId(),
                        sessionId: session.id,
                        tileId: tile.id,
                        src: tile.src,
                        badge: tile.badge
                    };

                    globalSelectedList.splice(newIndex, 0, newItem);

                    renderSelectedList();
                    updateSummary(session);
                    scheduleSave();
                },
                onEnd: function (evt) {
                    // Reorder based on DOM
                    const newOrderInstanceIds = Array.from(el.children).map(child => child.getAttribute('data-instance-id'));

                    const newGlobalList = [];
                    newOrderInstanceIds.forEach(instanceId => {
                        const item = globalSelectedList.find(i => i.instanceId === instanceId);
                        if (item) newGlobalList.push(item);
                    });

                    globalSelectedList = newGlobalList;

                    // Re-render to update numbering
                    renderSelectedList();
                    scheduleSave();
                }
            });
        }

        function resetWorkspace() {
            if (confirm("ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰å†å²è®°å½•å—ï¼Ÿ")) {
                sessions = [];
                activeSessionId = null;
                globalSelectedList = [];

                document.getElementById('gridContainer').style.display = 'none';
                document.getElementById('workspaceActions').style.display = 'none';
                document.getElementById('uploadArea').style.display = 'flex';

                renderSelectedList();
                renderSessionList();
                scheduleSave();
            }
        }

        function resetToInitialView({ clearState, saveState, resetPrompts } = { clearState: false, saveState: false, resetPrompts: false }) {
            const splitResults = document.getElementById('splitResults');
            const stepInput = document.getElementById('step-input');
            const stepReview = document.getElementById('step-script-review');
            const stepWorkspace = document.getElementById('step-workspace');
            const fullScriptInput = document.getElementById('fullScriptInput');
            const scriptInput = document.getElementById('scriptInput');
            const scriptListContainer = document.getElementById('scriptListContainer');
            const sceneRefContainer = document.getElementById('sceneRefImages');
            const scriptRefContainer = document.getElementById('scriptRefImages');
            const sceneRefPlaceholder = document.getElementById('sceneRefPlaceholder');
            const scriptRefPlaceholder = document.getElementById('scriptRefPlaceholder');

            if (clearState) {
                splitScriptText = '';
                splitScenes = [];
                currentSceneText = '';
            }

            if (fullScriptInput) {
                fullScriptInput.value = clearState ? '' : '';
                autoResize(fullScriptInput, 80);
            }
            if (scriptInput) {
                scriptInput.value = clearState ? '' : '';
                autoResize(scriptInput, 100);
            }
            if (splitResults) {
                splitResults.style.display = 'none';
                splitResults.innerHTML = '';
            }
            if (scriptListContainer) {
                scriptListContainer.innerHTML = '<div style="text-align: center; color: var(--text-sub); padding: 20px;">ç­‰å¾…ç”Ÿæˆ...</div>';
            }
            if (sceneRefContainer) sceneRefContainer.innerHTML = '';
            if (scriptRefContainer) scriptRefContainer.innerHTML = '';
            if (sceneRefPlaceholder) sceneRefPlaceholder.classList.remove('has-items');
            if (scriptRefPlaceholder) scriptRefPlaceholder.classList.remove('has-items');

            if (stepInput) stepInput.classList.add('step-hidden');
            if (stepReview) stepReview.classList.add('step-hidden');
            if (stepWorkspace) stepWorkspace.classList.add('step-hidden');

            document.getElementById('gridContainer').style.display = 'none';
            document.getElementById('workspaceActions').style.display = 'none';
            document.getElementById('uploadArea').style.display = 'flex';

            if (resetPrompts) {
                promptConfig.split = promptDefaults.split;
                promptConfig.shot = promptDefaults.shot;
            }
            if (saveState) scheduleSave();
        }

        function createEmptySession() {
            activeSessionId = null;
            renderSessionList();
            resetToInitialView({ clearState: true, saveState: true, resetPrompts: true });
        }

        function exportSelectedList() {
            if (globalSelectedList.length === 0) {
                alert("å·¦ä¾§å·²é€‰åˆ—è¡¨ä¸ºç©ºï¼");
                return;
            }

            const zip = new JSZip();
            const folder = zip.folder("Selected_Export");

            globalSelectedList.forEach((item, index) => {
                const base64Data = item.src.split(',')[1];
                const fileName = `Sequence_${String(index + 1).padStart(3, '0')}.jpg`;
                folder.file(fileName, base64Data, { base64: true });
            });

            zip.generateAsync({ type: "blob" })
                .then(function (content) {
                    saveAs(content, "Selected_Global.zip");
                });
        }
        /* fillPresetScript and fillPresetSegment removed */
    </script>
</body>

</html>